<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:url" content="https://agaura.github.io/kinetic-dither-shader/">
  <meta property="og:site_name" content="Alexander Gaura">
  <meta property="og:title" content="Kinetic Dither Shader">
  <meta property="og:description" content="Introduction This shader displays images with a portion of the color wheel being impossible to show, instead being displayed as noise being dithered so as to approximate that color. For more information, see here.
Shader ▶️ Upload Controls ▶️/⏸ Button: Controls time, causes noisiness to evolve over time and smoothens dither Slider: Controls the annihilated hue. Runs counterclockwise starting from the rightmost point of the color wheel (red/hot pink) Slider: Controls with width of the sector being annihilated, where the percentage corresponding to the percentage of the color wheel within that sector, centered around the annihilated hue as defined by the above slider Slider: Changes the size of the resolution of the dithered annihilated colors Discussion This shader more-or-less functions as a fun little artistic thingy.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2022-04-27T11:52:10+02:02">
    <meta property="article:modified_time" content="2022-04-27T11:52:10+02:02">
    <meta property="article:tag" content="Shader">
    <meta property="article:tag" content="Dither">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Kinetic Dither Shader">
  <meta name="twitter:description" content="Introduction This shader displays images with a portion of the color wheel being impossible to show, instead being displayed as noise being dithered so as to approximate that color. For more information, see here.
Shader ▶️ Upload Controls ▶️/⏸ Button: Controls time, causes noisiness to evolve over time and smoothens dither Slider: Controls the annihilated hue. Runs counterclockwise starting from the rightmost point of the color wheel (red/hot pink) Slider: Controls with width of the sector being annihilated, where the percentage corresponding to the percentage of the color wheel within that sector, centered around the annihilated hue as defined by the above slider Slider: Changes the size of the resolution of the dithered annihilated colors Discussion This shader more-or-less functions as a fun little artistic thingy.">

  
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-BBWS173BMQ"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-BBWS173BMQ');
        }
      </script>
    
  


  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#262d33">
  <title>
    
    Alexander Gaura - Kinetic Dither Shader
    
  </title>
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap"
    rel="stylesheet">
  
  
  
  <link rel="stylesheet" href="/minima.1742165536.css">

  
  
  <script defer type="text/javascript" src="/minima.1742165536.js"></script>
</head>
<script>
  
  let theme_2b_used = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

  try {
    if (!('theme' in localStorage)) {
      const default_theme = 'system';
      
      
      if (default_theme === 'dark' || default_theme === 'light') {
        theme_2b_used = default_theme;
      }

      
      localStorage.theme = theme_2b_used;
    }
    
    document.querySelector('html').classList.add(localStorage.theme);
  } catch (e) {
    console.error(e);
  }
</script>


<body class=" sm:mx-5 sm:my-0">
  <header class="flex justify-between items-center mb-6 sm:my-3">
  <div class="flex items-center">
    
    <div id="theme-switcher" class="text-4xl cursor-pointer">⚫️</div>
  </div>
  <nav class="flex items-center
    whitespace-nowrap overflow-x-auto overflow-y-hidden">
    
    <a class="ml-5" href="/">Home</a>
    
    <a class="ml-5" href="/categories/writing">Writing</a>
    
    <a class="ml-5" href="/categories/projects">Projects</a>
    
    <a class="ml-5" href="/about">About</a>
    
  </nav>
</header>
  
  

<h1 class="mt-6 mb-6">Kinetic Dither Shader</h1>
<div class="mb-3 text-xs flex justify-between sm:flex-col">
	<div>
	
		Posted at &mdash; Apr 27, 2022
	
		
	</div>
	
	<div class="sm:mt-4">
		
		<a class="not-first:ml-3" href="/tags/shader">#shader</a>
		
		<a class="not-first:ml-3" href="/tags/dither">#dither</a>
		
	</div>
	
</div>
<main>
	<p></p>
	<article class="md">
		<h1 id="introduction">Introduction</h1>
<p>       This shader displays images with a portion of the color wheel being impossible to show, instead being displayed as noise being dithered so as to approximate that color. For more information, see <a href="https://agaura.github.io/okhslapp/">here</a>.</p>
<h1 id="shader">Shader</h1>
<html>
 <!-- D3.js -->
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <script src="https://unpkg.com/d3-simple-slider"></script>    <!-- topojson -->
    <script src="https://unpkg.com/topojson@3"></script>    <!-- WebGL -->
    <script src="https://webgl2fundamentals.org/webgl/resources/webgl-utils.js"></script>
	<b style="font-size:30px" id='btn' onmouseover="this.style.cursor='pointer';" width = 20px>▶️</b>
    <style>
        input[type="file"] {
            display: none;
        }        .custom-file-upload {
            border: 1px solid #ccc;
            display: inline-block;
            padding: 6px 12px;
            cursor: pointer;
        }
    </style>    <div align="center">
        <label class="custom-file-upload">
            <input id="uploadImage" type="file" name="myPhoto" onchange="PreviewImage();" />
            <i class="fa fa-cloud-upload"></i>  Upload
        </label>
    </div>    <div align="center" style="padding-top: 20px">
        <canvas id="canvas"></canvas>
        <!--
for most samples webgl-utils only provides shader compiling/linking and
canvas resizing because why clutter the examples with code that's the same in every sample.
See https://webgl2fundamentals.org/webgl/lessons/webgl-boilerplate.html
and https://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
for webgl-utils, m3, m4, and webgl-lessons-ui.
-->
    </div>
	<div align="center" id="slider-fill" ><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" style = "position:relative; top:-23px;">
	<linearGradient id="Gradient2" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#d60071"/>
        <stop offset="20%" stop-color="#c04e00"/>
		<stop offset="30%" stop-color="#917200"/>
		<stop id = 'example' offset="45%" stop-color="#468a00"/>
		<stop offset="50%" stop-color="#008a79"/>
		<stop offset="60%" stop-color="#0083a8"/>
		<stop offset="70%" stop-color="#4b5dff"/>
		<stop offset="100%" stop-color="#b200df"/>
      </linearGradient>
	  <path fill="url(#Gradient2)" d="M12 0c-4.87 7.197-8 11.699-8 16.075 0 4.378 3.579 7.925 8 7.925s8-3.547 8-7.925c0-4.376-3.13-8.878-8-16.075zm.462 20.471c2.56-1.049 4.124-4.889 3.021-8.853 3.798 4.909.754 9.393-3.021 8.853z"/></svg></div>
	<div align="center" id="slider-fill2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" style = "position:relative; top:-23px;"><path fill = 'gray' d="M6 11v-4l-6 5 6 5v-4h12v4l6-5-6-5v4z"/></svg></div>
	<div align="center" id="slider-fill3"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" style = "position:relative; top:-23px;"><path fill = 'gray' d="M12 0l-11 6v12.131l11 5.869 11-5.869v-12.066l-11-6.065zm9 11.623l-3 1.569v-3.26l3-1.601v3.292zm-13-.654l3 1.625v3.186l-3-1.614v-3.197zm.9-1.799l2.986-1.603 3.132 1.688-3.014 1.608-3.104-1.693zm4.1 3.43l3-1.6v3.238l-3 1.569v-3.207zm4.138-4.475l-3.139-1.691 2.801-1.503 3.11 1.715-2.772 1.479zm-2.424-4.345l-2.825 1.517-2.728-1.47 2.834-1.546 2.719 1.499zm-7.649 1.19l2.711 1.46-2.973 1.596-2.67-1.456 2.932-1.6zm-1.065 4.908v3.204l-3-1.636v-3.216l3 1.648zm-3 3.843l3 1.636v3.185l-3-1.611v-3.21zm5 5.888v-3.169l3 1.614v3.146l-3-1.591zm5-1.545l3-1.569v3.104l-3 1.601v-3.136zm5 .468v-3.083l3-1.569v3.051l-3 1.601z"/></svg></div>
    <script type="text/javascript">
        "use strict";        var vertexShaderSource = `#version 300 es
        // an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec2 a_position;
in vec2 a_texCoord;// Used to pass in the resolution of the canvas
uniform vec2 u_resolution;// Used to pass the texture coordinates to the fragment shader
out vec2 v_texCoord;// all shaders have a main function
void main() {// convert the position from pixels to 0.0 to 1.0
vec2 zeroToOne = a_position / u_resolution;// convert from 0->1 to 0->2
vec2 zeroToTwo = zeroToOne * 2.0;// convert from 0->2 to -1->+1 (clipspace)
vec2 clipSpace = zeroToTwo - 1.0;gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);// pass the texCoord to the fragment shader
// The GPU will interpolate this value between points.
v_texCoord = a_texCoord;
}
`;        var fragmentShaderSource = `#version 300 es
// fragment shaders don't have a default precision so we need
// to pick one. highp is a good default. It means "high precision"
precision highp float;float rand(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}// Copyright(c) 2021 Björn Ottosson
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this softwareand associated documentation files(the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions :
// The above copyright noticeand this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
#define M_PI 3.1415926535897932384626433832795
float cbrt( float x )
{
    return sign(x)*pow(abs(x),1.0f/3.0f);
}float srgb_transfer_function(float a)
{
	return .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;
}float srgb_transfer_function_inv(float a)
{
	return .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;
}vec3 linear_srgb_to_oklab(vec3 c)
{
	float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;
	float m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;
	float s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;	float l_ = cbrt(l);
	float m_ = cbrt(m);
	float s_ = cbrt(s);	return vec3(
		0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,
		1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,
		0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_
	);
}vec3 oklab_to_linear_srgb(vec3 c)
{
	float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;
	float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;
	float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;	float l = l_ * l_ * l_;
	float m = m_ * m_ * m_;
	float s = s_ * s_ * s_;	return vec3(
		+4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,
		-1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,
		-0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s
	);
}// Finds the maximum saturation possible for a given hue that fits in sRGB
// Saturation here is defined as S = C/L
// a and b must be normalized so a^2 + b^2 == 1
float compute_max_saturation(float a, float b)
{
	// Max saturation will be when one of r, g or b goes below zero.	// Select different coefficients depending on which component goes below zero first
	float k0, k1, k2, k3, k4, wl, wm, ws;	if (-1.88170328f * a - 0.80936493f * b > 1.f)
	{
		// Red component
		k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;
		wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;
	}
	else if (1.81444104f * a - 1.19445276f * b > 1.f)
	{
		// Green component
		k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;
		wl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;
	}
	else
	{
		// Blue component
		k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;
		wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;
	}	// Approximate max saturation using a polynomial:
	float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;	// Do one step Halley's method to get closer
	// this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
	// this should be sufficient for most applications, otherwise do two/three steps
    float k_l = +0.3963377774f * a + 0.2158037573f * b;
	float k_m = -0.1055613458f * a - 0.0638541728f * b;
	float k_s = -0.0894841775f * a - 1.2914855480f * b;	{
		float l_ = 1.f + S * k_l;
		float m_ = 1.f + S * k_m;
		float s_ = 1.f + S * k_s;		float l = l_ * l_ * l_;
		float m = m_ * m_ * m_;
		float s = s_ * s_ * s_;		float l_dS = 3.f * k_l * l_ * l_;
		float m_dS = 3.f * k_m * m_ * m_;
		float s_dS = 3.f * k_s * s_ * s_;		float l_dS2 = 6.f * k_l * k_l * l_;
		float m_dS2 = 6.f * k_m * k_m * m_;
		float s_dS2 = 6.f * k_s * k_s * s_;		float f = wl * l + wm * m + ws * s;
		float f1 = wl * l_dS + wm * m_dS + ws * s_dS;
		float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;		S = S - f * f1 / (f1 * f1 - 0.5f * f * f2);
	}	return S;
}// finds L_cusp and C_cusp for a given hue
// a and b must be normalized so a^2 + b^2 == 1
vec2 find_cusp(float a, float b)
{
	// First, find the maximum saturation (saturation S = C/L)
	float S_cusp = compute_max_saturation(a, b);	// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
	vec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));
	float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));
	float C_cusp = L_cusp * S_cusp;	return vec2( L_cusp , C_cusp );
}// Finds intersection of the line defined by 
// L = L0 * (1 - t) + t * L1;
// C = t * C1;
// a and b must be normalized so a^2 + b^2 == 1
float find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)
{
	// Find the intersection for upper and lower half seprately
	float t;
	if (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)
	{
		// Lower half	
        t = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));
	}
	else
	{
		// Upper half		// First intersect with triangle
		t = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));		// Then one step Halley's method
		{
			float dL = L1 - L0;
			float dC = C1;			float k_l = +0.3963377774f * a + 0.2158037573f * b;
			float k_m = -0.1055613458f * a - 0.0638541728f * b;
			float k_s = -0.0894841775f * a - 1.2914855480f * b;			float l_dt = dL + dC * k_l;
			float m_dt = dL + dC * k_m;
			float s_dt = dL + dC * k_s;
			// If higher accuracy is required, 2 or 3 iterations of the following block can be used:
			{
				float L = L0 * (1.f - t) + t * L1;
				float C = t * C1;				float l_ = L + C * k_l;
				float m_ = L + C * k_m;
				float s_ = L + C * k_s;				float l = l_ * l_ * l_;
				float m = m_ * m_ * m_;
				float s = s_ * s_ * s_;				float ldt = 3.f * l_dt * l_ * l_;
				float mdt = 3.f * m_dt * m_ * m_;
				float sdt = 3.f * s_dt * s_ * s_;				float ldt2 = 6.f * l_dt * l_dt * l_;
				float mdt2 = 6.f * m_dt * m_dt * m_;
				float sdt2 = 6.f * s_dt * s_dt * s_;				float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;
				float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;
				float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;				float u_r = r1 / (r1 * r1 - 0.5f * r * r2);
				float t_r = -r * u_r;				float g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;
				float g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;
				float g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;				float u_g = g1 / (g1 * g1 - 0.5f * g * g2);
				float t_g = -g * u_g;				float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;
				float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;
				float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;				float u_b = b1 / (b1 * b1 - 0.5f * b * b2);
				float t_b = -b * u_b;				t_r = u_r >= 0.f ? t_r : 10000.f;
				t_g = u_g >= 0.f ? t_g : 10000.f;
				t_b = u_b >= 0.f ? t_b : 10000.f;				t += min(t_r, min(t_g, t_b));
			}
		}
	}	return t;
}float find_gamut_intersection(float a, float b, float L1, float C1, float L0)
{
	// Find the cusp of the gamut triangle
	vec2 cusp = find_cusp(a, b);	return find_gamut_intersection(a, b, L1, C1, L0, cusp);
}vec3 gamut_clip_preserve_chroma(vec3 rgb)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;	float L0 = clamp(L, 0.f, 1.f);	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}vec3 gamut_clip_project_to_0_5(vec3 rgb)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;	float L0 = 0.5;	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}vec3 gamut_clip_project_to_L_cusp(vec3 rgb)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
	vec2 cusp = find_cusp(a_, b_);	float L0 = cusp.x;	float t = find_gamut_intersection(a_, b_, L, C, L0);	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}vec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;	float Ld = L - 0.5f;
	float e1 = 0.5f + abs(Ld) + alpha * C;
	float L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}vec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)
{
	if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
		return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);	float L = lab.x;
	float eps = 0.00001f;
	float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
	float a_ = lab.y / C;
	float b_ = lab.z / C;	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
	vec2 cusp = find_cusp(a_, b_);	float Ld = L - cusp.x;
	float k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);	float e1 = 0.5f * k + abs(Ld) + alpha * C / k;
	float L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));	float t = find_gamut_intersection(a_, b_, L, C, L0);
	float L_clipped = L0 * (1.f - t) + t * L;
	float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}float toe(float x)
{
	float k_1 = 0.206f;
	float k_2 = 0.03f;
	float k_3 = (1.f + k_1) / (1.f + k_2);
	return 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));
}float toe_inv(float x)
{
	float k_1 = 0.206f;
	float k_2 = 0.03f;
	float k_3 = (1.f + k_1) / (1.f + k_2);
	return (x * x + k_1 * x) / (k_3 * (x + k_2));
}vec2 to_ST(vec2 cusp)
{
	float L = cusp.x;
	float C = cusp.y;
	return vec2( C / L, C / (1.f - L) );
}// Returns a smooth approximation of the location of the cusp
// This polynomial was created by an optimization process
// It has been designed so that S_mid < S_max and T_mid < T_max
vec2 get_ST_mid(float a_, float b_)
{
	float S = 0.11516993f + 1.f / (
		+7.44778970f + 4.15901240f * b_
		+ a_ * (-2.19557347f + 1.75198401f * b_
			+ a_ * (-2.13704948f - 10.02301043f * b_
				+ a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_
					)))
		);	float T = 0.11239642f + 1.f / (
		+1.61320320f - 0.68124379f * b_
		+ a_ * (+0.40370612f + 0.90148123f * b_
			+ a_ * (-0.27087943f + 0.61223990f * b_
				+ a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_
					)))
		);	return vec2( S, T );
}vec3 get_Cs(float L, float a_, float b_)
{
	vec2 cusp = find_cusp(a_, b_);	float C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);
	vec2 ST_max = to_ST(cusp);
	// Scale factor to compensate for the curved part of gamut shape:
	float k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);	float C_mid;
	{
		vec2 ST_mid = get_ST_mid(a_, b_);		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
		float C_a = L * ST_mid.x;
		float C_b = (1.f - L) * ST_mid.y;
		C_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));
	}	float C_0;
	{
		// for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.
		float C_a = L * 0.4f;
		float C_b = (1.f - L) * 0.8f;		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
		C_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));
	}	return vec3( C_0, C_mid, C_max );
}vec3 okhsl_to_srgb(vec3 hsl)
{
	float h = hsl.x;
	float s = hsl.y;
	float l = hsl.z;	if (l == 1.0f)
	{
		return vec3( 1.f, 1.f, 1.f );
	}	else if (l == 0.f)
	{
		return vec3( 0.f, 0.f, 0.f );
	}	float a_ = cos(2.f * M_PI * h);
	float b_ = sin(2.f * M_PI * h);
	float L = toe_inv(l);	vec3 cs = get_Cs(L, a_, b_);
	float C_0 = cs.x;
	float C_mid = cs.y;
	float C_max = cs.z;
    float mid = 0.8f;
	float mid_inv = 1.25f;	float C, t, k_0, k_1, k_2;	if (s < mid)
	{
		t = mid_inv * s;		k_1 = mid * C_0;
		k_2 = (1.f - k_1 / C_mid);		C = t * k_1 / (1.f - k_2 * t);
	}
	else
	{
		t = (s - mid)/ (1.f - mid);		k_0 = C_mid;
		k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
		k_2 = (1.f - (k_1) / (C_max - C_mid));		C = k_0 + t * k_1 / (1.f - k_2 * t);
	}	vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));
	return vec3(
		srgb_transfer_function(rgb.r),
		srgb_transfer_function(rgb.g),
		srgb_transfer_function(rgb.b)
	);
}vec3 srgb_to_okhsl(vec3 rgb)
{
	vec3 lab = linear_srgb_to_oklab(vec3(
		srgb_transfer_function_inv(rgb.r),
		srgb_transfer_function_inv(rgb.g),
		srgb_transfer_function_inv(rgb.b)
		));	float C = sqrt(lab.y * lab.y + lab.z * lab.z);
	float a_ = lab.y / C;
	float b_ = lab.z / C;	float L = lab.x;
	float h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;	vec3 cs = get_Cs(L, a_, b_);
	float C_0 = cs.x;
	float C_mid = cs.y;
	float C_max = cs.z;	// Inverse of the interpolation in okhsl_to_srgb:
    float mid = 0.8f;
	float mid_inv = 1.25f;	float s;
	if (C < C_mid)
	{
		float k_1 = mid * C_0;
		float k_2 = (1.f - k_1 / C_mid);		float t = C / (k_1 + k_2 * C);
		s = t * mid;
	}
	else
	{
		float k_0 = C_mid;
		float k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
		float k_2 = (1.f - (k_1) / (C_max - C_mid));		float t = (C - k_0) / (k_1 + k_2 * (C - k_0));
		s = mid + (1.f - mid) * t;
	}	float l = toe(L);
	return vec3( h, s, l );
}
vec3 okhsv_to_srgb(vec3 hsv)
{
	float h = hsv.x;
	float s = hsv.y;
	float v = hsv.z;	float a_ = cos(2.f * M_PI * h);
	float b_ = sin(2.f * M_PI * h);
	vec2 cusp = find_cusp(a_, b_);
	vec2 ST_max = to_ST(cusp);
	float S_max = ST_max.x;
	float T_max = ST_max.y;
	float S_0 = 0.5f;
	float k = 1.f- S_0 / S_max;	// first we compute L and V as if the gamut is a perfect triangle:	// L, C when v==1:
	float L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);
	float C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);	float L = v * L_v;
	float C = v * C_v;	// then we compensate for both toe and the curved top part of the triangle:
	float L_vt = toe_inv(L_v);
	float C_vt = C_v * L_vt / L_v;	float L_new = toe_inv(L);
	C = C * L_new / L;
	L = L_new;	vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));
	float scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));	L = L * scale_L;
	C = C * scale_L;	vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));
	return vec3(
		srgb_transfer_function(rgb.r),
		srgb_transfer_function(rgb.g),
		srgb_transfer_function(rgb.b)
	);
}vec3 srgb_to_okhsv(vec3 rgb)
{
	vec3 lab = linear_srgb_to_oklab(vec3(
		srgb_transfer_function_inv(rgb.r),
		srgb_transfer_function_inv(rgb.g),
		srgb_transfer_function_inv(rgb.b)
		));	float C = sqrt(lab.y * lab.y + lab.z * lab.z);
	float a_ = lab.y / C;
	float b_ = lab.z / C;	float L = lab.x;
	float h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;	vec2 cusp = find_cusp(a_, b_);
	vec2 ST_max = to_ST(cusp);
	float S_max = ST_max.x;
	float T_max = ST_max.y;
	float S_0 = 0.5f;
	float k = 1.f - S_0 / S_max;	// first we find L_v, C_v, L_vt and C_vt
    float t = T_max / (C + L * T_max);
	float L_v = t * L;
	float C_v = t * C;	float L_vt = toe_inv(L_v);
	float C_vt = C_v * L_vt / L_v;	// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
	vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));
	float scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));	L = L / scale_L;
	C = C / scale_L;	C = C * toe(L) / L;
	L = toe(L);	// we can now compute v and s:
    float v = L / L_v;
	float s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);	return vec3 (h, s, v );
}vec3 hsl2rgb( in vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
}vec3 rgb2hsl( in vec3 c ){
  float h = 0.0;
	float s = 0.0;
	float l = 0.0;
	float r = c.r;
	float g = c.g;
	float b = c.b;
	float cMin = min( r, min( g, b ) );
	float cMax = max( r, max( g, b ) );	l = ( cMax + cMin ) / 2.0;
	if ( cMax > cMin ) {
		float cDelta = cMax - cMin;
        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original
		s = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );
		if ( r == cMax ) {
			h = ( g - b ) / cDelta;
		} else if ( g == cMax ) {
			h = 2.0 + ( b - r ) / cDelta;
		} else {
			h = 4.0 + ( r - g ) / cDelta;
		}		if ( h < 0.0) {
			h += 6.0;
		}
		h = h / 6.0;
	}
	return vec3( h, s, l );
}
bool inDither( float h, float antiHue, float antiRad) {
	return (((h > antiHue - antiRad) && (h < antiHue + antiRad))) ||
	(((h - 1.0f > antiHue - antiRad) && (h - 1.0f < antiHue + antiRad))) ||
	(((1.0f + h > antiHue - antiRad) && (1.0f + h < antiHue + antiRad)));
}
float dither( float h, float r, float antiHue, float antiRad) {
	float rightBound = antiHue - antiRad;
    if (rightBound < -0.5f) rightBound = rightBound + 1.0f;
    float leftBound = antiHue + antiRad;
    if (leftBound > 0.5f) leftBound = leftBound - 1.0f;
	if ((h > antiHue - antiRad) && (h < antiHue + antiRad))
        if (((h - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
            h = rightBound;
        else h = leftBound;
    else if ((h - 1.0f > antiHue - antiRad) && (h - 1.0f < antiHue + antiRad))
        if (((h - 1.0f - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
            h = rightBound;
        else h = leftBound;
    else if ((1.0f + h > antiHue - antiRad) && (1.0f + h < antiHue + antiRad))
        if (((1.0f + h - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
            h = rightBound;
        else h = leftBound;
	return h;
}
uniform sampler2D u_image;
uniform float time;
uniform float antiHue;
uniform float antiRad;
uniform vec2 res;
// the texCoords passed in from the vertex shader.
in vec2 v_texCoord;// we need to declare an output for the fragment shader
out vec4 outColor;void main()
{
    vec2 uv = v_texCoord;
    float iTime = time / 1.0;
	vec4 tex = texture(u_image, uv);
    vec3 hsl = srgb_to_okhsl(tex.rgb);
    float h = hsl.x;
    float s = hsl.y;
	float temp = h;
	if (inDither(h, antiHue, antiRad)) {
		uv = clamp(floor((uv-0.5)*res)/res + 0.5 + 0.5/res, 0.5/res, 1.0 - 0.5/res);
		temp = srgb_to_okhsl(texture(u_image, uv).rgb).x;
		if ((uv.x == 0.0) && (uv.y == 0.0)) h = atan(1.0, 1.0)/(2.0*M_PI);
		if (inDither(temp, antiHue, antiRad)) h = temp;
	}
    if (s > 1.0) s = 1.0;
    float r = rand(vec2(uv.x, iTime));
    r = rand(vec2(r, uv.y));
	h = dither(h, r, antiHue, antiRad);
    vec3 col = okhsl_to_srgb(vec3(h, s, hsl.z));
	col = s > 1.0 ? vec3(0.0) : col;
    outColor = vec4(col,tex.w);
}`;        // Get A WebGL context
        /** @type {HTMLCanvasElement} */
		var toggle = true;
		const btn = document.getElementById('btn');
        var canvas = document.querySelector("canvas");
        var gl = canvas.getContext("webgl2");        // setup GLSL program
        var program = webglUtils.createProgramFromSources(gl,
            [vertexShaderSource, fragmentShaderSource]);        // look up where the vertex data needs to go.
        var positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        var texCoordAttributeLocation = gl.getAttribLocation(program, "a_texCoord");
		var locs = {
        'time': gl.getUniformLocation(program, "time"),
        'hue': gl.getUniformLocation(program, "antiHue"),
        'rad': gl.getUniformLocation(program, "antiRad"),
        'res': gl.getUniformLocation(program, "res")
    };
        var timeLocation = gl.getUniformLocation(program, "time");
        var hueLocation = gl.getUniformLocation(program, "antiHue");
        var radLocation = gl.getUniformLocation(program, "antiRad");
        var image = new Image();
		function resizeCanvas(image, multiplier) {
			const maxWidth = Math.min(600, screen.width * 0.85);
            multiplier = multiplier || 1;
            const width = Math.min(image.width, maxWidth) | 0;
            const height = Math.min(image.height, image.height/image.width * maxWidth) | 0;
            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
                return true;
            }
            return false;
        }
		function firstRender(time) {
            time = time || 0;            // lookup uniforms
            var resolutionLocation = gl.getUniformLocation(program, "u_resolution");
            var imageLocation = gl.getUniformLocation(program, "u_image");
			var resLocation = gl.getUniformLocation(program, "res");
            var vao = gl.createVertexArray();            // and make it the one we're currently working with
            gl.bindVertexArray(vao);            // Create a buffer and put a single pixel space rectangle in
            // it (2 triangles)
            var positionBuffer = gl.createBuffer();            // Turn on the attribute
            gl.enableVertexAttribArray(positionAttributeLocation);            // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);            // Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
            gl.vertexAttribPointer(
                positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);            // provide texture coordinates for the rectangle.
            var texCoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                0.0, 0.0,
                1.0, 0.0,
                0.0, 1.0,
                0.0, 1.0,
                1.0, 0.0,
                1.0, 1.0,
            ]), gl.STATIC_DRAW);            // Turn on the attribute
            gl.enableVertexAttribArray(texCoordAttributeLocation);            // Tell the attribute how to get data out of texCoordBuffer (ARRAY_BUFFER)
            gl.vertexAttribPointer(
                texCoordAttributeLocation, 2, gl.FLOAT, false, 0, 0);            // Create a texture.
            var texture = gl.createTexture();            // make unit 0 the active texture uint
            // (ie, the unit all other texture commands will affect
            gl.bindTexture(gl.TEXTURE_2D, texture);            // Set the parameters so we don't need mips and so we're not filtering
            // and we don't repeat
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texImage2D(gl.TEXTURE_2D,
                0,
                gl.RGBA,
                gl.RGBA,
                gl.UNSIGNED_BYTE,
                image);
			resizeCanvas(image);            // Tell WebGL how to convert from clip space to pixels
            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);            // Clear the canvas
            gl.useProgram(program);            // Bind the attribute/buffer set we want.
            // pixels to clipspace in the shader
            gl.uniform2f(resolutionLocation, image.width, image.height);            // Tell the shader to get the texture from texture unit 0
            gl.uniform1i(imageLocation, 0);            // Update the time
            gl.uniform1f(locs.time, time * 0.001);
			gl.uniform1f(locs.hue, sliderFill.value());
            gl.uniform1f(locs.rad, sliderFill2.value() / 2.0);
			gl.uniform2f(locs.res, image.width*Math.pow(1 - sliderFill3.value(), 4) + 1,image.height*Math.pow(1 - sliderFill3.value(), 4) + 1);
            // in setRectangle puts data in the position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);            // Set a rectangle the same size as the image.
            setRectangle(gl, 0, 0, image.width, image.height);            // Draw the rectangle.
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }
		function render(time) {
        	time = time || 0;
        	gl.uniform1f(locs.time, time * 0.001);
        	gl.uniform1f(locs.hue, sliderFill.value());
        	gl.uniform1f(locs.rad, sliderFill2.value() / 2.0);
			gl.uniform2f(locs.res, image.width*Math.pow(1 - sliderFill3.value(), 4) + 1,image.height*Math.pow(1 - sliderFill3.value(), 4) + 1);
        	gl.drawArrays(gl.TRIANGLES, 0, 6);
        	if (!toggle) requestAnimationFrame(render);
    	}
		function setRectangle(gl, x, y, width, height) {
            var x1 = x;
            var x2 = x + width;
            var y1 = y;
            var y2 = y + height;
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
                x1, y1,
                x2, y1,
                x1, y2,
                x1, y2,
                x2, y1,
                x2, y2,
            ]), gl.STATIC_DRAW);
        }
		function PreviewImage() {
            var oFReader = new FileReader();
            oFReader.readAsDataURL(document.getElementById("uploadImage").files[0]);
			oFReader.onload = function (oFREvent) {
                image.src = oFREvent.target.result;
            };
			image.onload = function () {
                firstRender();
			};
        }
		function componentToHex(c) {
			var hex = c.toString(16);
			return hex.length == 1 ? "0" + hex : hex;
		}
		function rgbToHex(r, g, b) {
			return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
		}
		function hexToRgb(hex) {
			var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result ? {
				r: parseInt(result[1], 16),
				g: parseInt(result[2], 16),
				b: parseInt(result[3], 16)
  				} : null;
			}
		function hslToRgb(h, s, l){
		    var r, g, b;
    		if(s == 0){
       			 r = g = b = l; // achromatic
    		}else{
        		var hue2rgb = function hue2rgb(p, q, t){
	        	    if(t < 0) t += 1;
   	    		    if(t > 1) t -= 1;
    	    	    if(t < 1/6) return p + (q - p) * 6 * t;
	        	    if(t < 1/2) return q;
    	    	    if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            		return p;
        		}
        		var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        		var p = 2 * l - q;
        		r = hue2rgb(p, q, h + 1/3);
        		g = hue2rgb(p, q, h);
        		b = hue2rgb(p, q, h - 1/3);
    		}
    		return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
		}
		function rgbToHsl(r, g, b){
    		r /= 255, g /= 255, b /= 255;
    		var max = Math.max(r, g, b), min = Math.min(r, g, b);
    		var h, s, l = (max + min) / 2;
    		if(max == min){
       		 h = s = 0; // achromatic
    		}else{
        		var d = max - min;
        		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        		switch(max){
            		case r: h = (g - b) / d + (g < b ? 6 : 0); break;
            		case g: h = (b - r) / d + 2; break;
            		case b: h = (r - g) / d + 4; break;
        		}
        		h /= 6;
    		}
    		return [h, s, l];
		}
		var colors = ['#d60071', '#d7006d', '#d7006a', '#d80066', '#d80063', '#d9005f', '#da005b', '#da0058', '#da0054', '#db0050', '#db004c', '#dc0048', '#dc0043', '#dd003f', '#dd003a', '#dd0035', '#de002f', '#de0029', '#de0022', '#df001a', '#df000e', '#de0700', '#db1c00', '#d72700', '#d42f00', '#d13500', '#ce3b00', '#cc3f00', '#c94300', '#c74600', '#c54900', '#c24c00', '#c04e00', '#be5100', '#bc5300', '#bb5500', '#b95600', '#b75800', '#b55a00', '#b45b00', '#b25c00', '#b05e00', '#af5f00', '#ad6000', '#ac6100', '#aa6300', '#a96400', '#a86500', '#a66600', '#a56700', '#a46700', '#a26800', '#a16900', '#a06a00', '#9e6b00', '#9d6c00', '#9c6d00', '#9a6d00', '#996e00', '#986f00', '#967000', '#957000', '#947100', '#927200', '#917200', '#907300', '#8e7400', '#8d7400', '#8c7500', '#8a7600', '#897600', '#877700', '#867800', '#847800', '#837900', '#817a00', '#7f7a00', '#7e7b00', '#7c7c00', '#7a7d00', '#787d00', '#767e00', '#747f00', '#727f00', '#708000', '#6e8100', '#6b8200', '#698200', '#668300', '#638400', '#608500', '#5d8600', '#598700', '#558800', '#518800', '#4c8900', '#468a00', '#408b00', '#398d00', '#308e00', '#238f00', '#0e9000', '#009014', '#009023', '#00902e', '#008f36', '#008f3c', '#008f42', '#008e47', '#008e4b', '#008e4f', '#008e53', '#008d56', '#008d59', '#008d5c', '#008d5f', '#008c61', '#008c64', '#008c66', '#008c68', '#008c6a', '#008b6c', '#008b6e', '#008b70', '#008b72', '#008b74', '#008a76', '#008a77', '#008a79', '#008a7a', '#008a7c', '#00897d', '#00897f', '#008980', '#008982', '#008983', '#008885', '#008886', '#008887', '#008889', '#00888a', '#00878b', '#00878d', '#00878e', '#00878f', '#008791', '#008692', '#008693', '#008695', '#008696', '#008697', '#008599', '#00859a', '#00859b', '#00859d', '#00849e', '#0084a0', '#0084a1', '#0084a3', '#0083a4', '#0083a6', '#0083a8', '#0082a9', '#0082ab', '#0082ad', '#0081af', '#0081b1', '#0080b3', '#0080b5', '#007fb7', '#007fb9', '#007ebc', '#007ebe', '#007dc1', '#007cc4', '#007cc7', '#007bca', '#007acd', '#0079d1', '#0077d5', '#0076da', '#0074df', '#0073e5', '#0070eb', '#006df3', '#0069fc', '#1467fe', '#2266ff', '#2c65ff', '#3363ff', '#3a62ff', '#4060ff', '#465fff', '#4b5dff', '#505cff', '#545aff', '#5859ff', '#5c57ff', '#6055ff', '#6453ff', '#6851ff', '#6c4fff', '#6f4dff', '#734bff', '#7649ff', '#7946ff', '#7d43ff', '#8040ff', '#833dff', '#873aff', '#8a36fe', '#8e32fe', '#912dfe', '#9427fe', '#9820fe', '#9b16ff', '#9f06fe', '#a101fc', '#a400f8', '#a600f5', '#a800f1', '#aa00ee', '#ac00ea', '#af00e7', '#b000e3', '#b200df', '#b400dc', '#b600d8', '#b800d4', '#b900d1', '#bb00cd', '#bd00ca', '#be00c6', '#c000c2', '#c100bf', '#c200bb', '#c400b7', '#c500b4', '#c600b0', '#c800ad', '#c900a9', '#ca00a5', '#cb00a2', '#cc009e', '#cd009b', '#ce0097', '#cf0094', '#d00090', '#d0008d', '#d10089', '#d20086', '#d30082', '#d4007f', '#d4007b', '#d50078', '#d60074']; 
		var grays = ['#000000', '#010101', '#020202', '#030303', '#040404', '#050505', '#060606', '#070707', '#080808', '#090909', '#0a0a0a', '#0b0b0b', '#0c0c0c', '#0d0d0d', '#0e0e0e', '#0f0f0f', '#101010', '#111111', '#121212', '#131313', '#141414', '#151515', '#161616', '#171717', '#181818', '#191919', '#1a1a1a', '#1b1b1b', '#1c1c1c', '#1d1d1d', '#1e1e1e', '#1f1f1f', '#202020', '#212121', '#222222', '#232323', '#242424', '#252525', '#262626', '#272727', '#282828', '#292929', '#2a2a2a', '#2b2b2b', '#2c2c2c', '#2d2d2d', '#2e2e2e', '#2f2f2f', '#303030', '#313131', '#323232', '#333333', '#343434', '#353535', '#363636', '#373737', '#383838', '#393939', '#3a3a3a', '#3b3b3b', '#3c3c3c', '#3d3d3d', '#3e3e3e', '#3f3f3f', '#404040', '#414141', '#424242', '#434343', '#444444', '#454545', '#464646', '#474747', '#484848', '#494949', '#4a4a4a', '#4b4b4b', '#4c4c4c', '#4d4d4d', '#4e4e4e', '#4f4f4f', '#505050', '#515151', '#525252', '#535353', '#545454', '#555555', '#565656', '#575757', '#585858', '#595959', '#5a5a5a', '#5b5b5b', '#5c5c5c', '#5d5d5d', '#5e5e5e', '#5f5f5f', '#606060', '#616161', '#626262', '#636363', '#646464', '#656565', '#666666', '#676767', '#686868', '#696969', '#6a6a6a', '#6b6b6b', '#6c6c6c', '#6d6d6d', '#6e6e6e', '#6f6f6f', '#707070', '#717171', '#727272', '#737373', '#747474', '#757575', '#767676', '#777777', '#787878', '#797979', '#7a7a7a', '#7b7b7b', '#7c7c7c', '#7d7d7d', '#7e7e7e', '#7f7f7f', '#808080', '#818181', '#828282', '#838383', '#848484', '#858585', '#868686', '#878787', '#888888', '#898989', '#8a8a8a', '#8b8b8b', '#8c8c8c', '#8d8d8d', '#8e8e8e', '#8f8f8f', '#909090', '#919191', '#929292', '#939393', '#949494', '#959595', '#969696', '#979797', '#989898', '#999999', '#9a9a9a', '#9b9b9b', '#9c9c9c', '#9d9d9d', '#9e9e9e', '#9f9f9f', '#a0a0a0', '#a1a1a1', '#a2a2a2', '#a3a3a3', '#a4a4a4', '#a5a5a5', '#a6a6a6', '#a7a7a7', '#a8a8a8', '#a9a9a9', '#aaaaaa', '#ababab', '#acacac', '#adadad', '#aeaeae', '#afafaf', '#b0b0b0', '#b1b1b1', '#b2b2b2', '#b3b3b3', '#b4b4b4', '#b5b5b5', '#b6b6b6', '#b7b7b7', '#b8b8b8', '#b9b9b9', '#bababa', '#bbbbbb', '#bcbcbc', '#bdbdbd', '#bebebe', '#bfbfbf', '#c0c0c0', '#c1c1c1', '#c2c2c2', '#c3c3c3', '#c4c4c4', '#c5c5c5', '#c6c6c6', '#c7c7c7', '#c8c8c8', '#c9c9c9', '#cacaca', '#cbcbcb', '#cccccc', '#cdcdcd', '#cecece', '#cfcfcf', '#d0d0d0', '#d1d1d1', '#d2d2d2', '#d3d3d3', '#d4d4d4', '#d5d5d5', '#d6d6d6', '#d7d7d7', '#d8d8d8', '#d9d9d9', '#dadada', '#dbdbdb', '#dcdcdc', '#dddddd', '#dedede', '#dfdfdf', '#e0e0e0', '#e1e1e1', '#e2e2e2', '#e3e3e3', '#e4e4e4', '#e5e5e5', '#e6e6e6', '#e7e7e7', '#e8e8e8', '#e9e9e9', '#eaeaea', '#ebebeb', '#ececec', '#ededed', '#eeeeee', '#efefef', '#f0f0f0', '#f1f1f1', '#f2f2f2', '#f3f3f3', '#f4f4f4', '#f5f5f5', '#f6f6f6', '#f7f7f7', '#f8f8f8', '#f9f9f9', '#fafafa', '#fbfbfb', '#fcfcfc', '#fdfdfd', '#fefefe', '#ffffff'];
        function sliderColor(origin, s, color_data) {
			var index = (s > 0.5) ? parseInt((origin * 255 + 128) % 256) : parseInt(origin * 255);
			var rgb = hexToRgb(color_data[index]);
			var hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
			hsl[1] = 2*Math.abs(s - 0.5)*(Math.abs(hsl[1] - 0.5) * 2);
			hsl[2] = hsl[2]*2*Math.abs(s - 0.5) + (1-2*Math.abs(s - 0.5))*0.5; // replace 0.5 with sliderFill3.value()
			var nrgb = hslToRgb(hsl[0],hsl[1],hsl[2]);
			var ncolor = rgbToHex(nrgb[0], nrgb[1], nrgb[2])
			return ncolor;
		}
        var data = [0, 1.0];      
        var sliderFill = d3
            .sliderBottom()
            .min(d3.min(data))
            .max(d3.max(data))
            .width(Math.min(300,screen.width*0.55))
            .tickFormat(d3.format('.0'))
            .ticks(5)
            .default(0.7)
            .fill('#415794')
            .handle(
                d3
                .symbol()
                .type(d3.symbolCircle)
                .size(250)
            )
            .on('onchange', val => {
                d3.select('div#slider-fill')
				//.select('g') 					// these provide text color
				//.attr("fill", colors[index])
				.select('.handle')
				.attr("fill", sliderColor(val, sliderFill2.value(), colors));
				if (toggle) render();
            });
        var gFill = d3
            .select('div#slider-fill')
            .append('svg')
            .attr('width', Math.min(350,screen.width*0.7))
            .attr('height', 65)
            .append('g')
            .attr('transform', 'translate(30,30)')
			.attr('fill', '#aaaaaa')
        gFill.call(sliderFill);
        var sliderFill2 = d3
            .sliderBottom()
            .min(d3.min(data))
            .max(d3.max(data))
            .width(Math.min(300,screen.width*0.55))
            .tickFormat(d3.format('.0%'))
            .ticks(5)
            .default(0.4)
            .fill('#415794')
			.handle(
                d3
                .symbol()
                .type(d3.symbolCircle)
                .size(250)
            )
			.on('onchange', val => {
				var index = parseInt((2-val)/2 * 255)
                d3.select('div#slider-fill2')
				.select('g')
				.attr("fill", grays[index])
				.select('.handle')
				.attr("fill", grays[index]);
				if (toggle) render();
				d3.select('div#slider-fill')
				//.select('g') 					// these provide text color
				//.attr("fill", colors[index])
				.select('.handle')
				.attr("fill", sliderColor(sliderFill.value(), val, colors));
				if (toggle) render();
            });
		var gFill2 = d3
            .select('div#slider-fill2')
            .append('svg')
            .attr('width', Math.min(350,screen.width*0.7))
            .attr('height', 65)
            .append('g')
            .attr('transform', 'translate(30,30)')
			.attr('fill', '#aaaaaa');
		gFill2.call(sliderFill2);
		var sliderFill3 = d3
            .sliderBottom()
            .min(d3.min(data))
            .max(d3.max(data))
            .width(Math.min(300,screen.width*0.55))
            .tickFormat(d3.format('.0%'))
            .ticks(5)
            .default(0.0)
            .fill('#415794')
			.handle(
                d3
                .symbol()
                .type(d3.symbolCircle)
                .size(250)
            )
			.on('onchange', val => {
				if (toggle) render();
            });
        var gFill3 = d3
            .select('div#slider-fill3')
            .append('svg')
            .attr('width', Math.min(350,screen.width*0.7))
            .attr('height', 65)
            .append('g')
            .attr('transform', 'translate(30,30)')
			.attr('fill', '#aaaaaa');
        gFill3.call(sliderFill3);
		gFill.select('.handle')
			.attr("fill", sliderColor(sliderFill.value(), sliderFill2.value(), colors));
		gFill2.select('.handle')
			.attr("fill", grays[parseInt(sliderFill2.value() * 255)]);
		window.onload=function(){
  			btn.addEventListener('click', function handleClick() {
				toggle = !toggle;
				if (toggle) btn.textContent = '▶️';
				else btn.textContent = '⏸';
				render();
			});
		}
	image.src = "/flower.jpeg";
	image.onload = function() {firstRender();}
		</script>
</html>
<h1 id="controls">Controls</h1>
<ul>
<li>▶️/⏸ Button: Controls time, causes noisiness to evolve over time and smoothens dither</li>
<li>
<html>
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
    style="position:relative; top:2px;">
    <linearGradient id="Gradient2" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#d60071" />
        <stop offset="20%" stop-color="#c04e00" />
        <stop offset="30%" stop-color="#917200" />
        <stop id='example' offset="45%" stop-color="#468a00" />
        <stop offset="50%" stop-color="#008a79" />
        <stop offset="60%" stop-color="#0083a8" />
        <stop offset="70%" stop-color="#4b5dff" />
        <stop offset="100%" stop-color="#b200df" />
    </linearGradient>
    <path fill="url(#Gradient2)"
        d="M12 0c-4.87 7.197-8 11.699-8 16.075 0 4.378 3.579 7.925 8 7.925s8-3.547 8-7.925c0-4.376-3.13-8.878-8-16.075zm.462 20.471c2.56-1.049 4.124-4.889 3.021-8.853 3.798 4.909.754 9.393-3.021 8.853z" /></svg>
        </html> Slider: Controls the annihilated hue. Runs counterclockwise starting from the rightmost point of the color wheel (red/hot pink)
</li>
<li>
<html>
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
    style="position:relative; top:2px;">
    <path fill='gray' d="M6 11v-4l-6 5 6 5v-4h12v4l6-5-6-5v4z" /></svg>
        </html> Slider: Controls with width of the sector being annihilated, where the percentage corresponding to the percentage of the color wheel within that sector, centered around the annihilated hue as defined by the above slider
</li>
<li>
<html>
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24"
    style="position:relative; top:2px;">
    <path fill='gray'
        d="M12 0l-11 6v12.131l11 5.869 11-5.869v-12.066l-11-6.065zm9 11.623l-3 1.569v-3.26l3-1.601v3.292zm-13-.654l3 1.625v3.186l-3-1.614v-3.197zm.9-1.799l2.986-1.603 3.132 1.688-3.014 1.608-3.104-1.693zm4.1 3.43l3-1.6v3.238l-3 1.569v-3.207zm4.138-4.475l-3.139-1.691 2.801-1.503 3.11 1.715-2.772 1.479zm-2.424-4.345l-2.825 1.517-2.728-1.47 2.834-1.546 2.719 1.499zm-7.649 1.19l2.711 1.46-2.973 1.596-2.67-1.456 2.932-1.6zm-1.065 4.908v3.204l-3-1.636v-3.216l3 1.648zm-3 3.843l3 1.636v3.185l-3-1.611v-3.21zm5 5.888v-3.169l3 1.614v3.146l-3-1.591zm5-1.545l3-1.569v3.104l-3 1.601v-3.136zm5 .468v-3.083l3-1.569v3.051l-3 1.601z" /></svg>
        </html> Slider: Changes the size of the resolution of the dithered annihilated colors
</li>
</ul>
<h1 id="discussion">Discussion</h1>
<p>       This shader more-or-less functions as a fun little artistic thingy. The effect works best on images with large regions that are nearly monochromatic and that contrast a lot with their environment, and whose color is saturated. Realistically, this means things like flowers, auroras, neon signs, etc. A lot of digital art tends to be made this way as well, I would recommend trying out some of your favorite images and seeing what happens. Have fun! :)</p>

	</article>
</main>







  <footer class="mt-8 flex sm:flex-col-reverse justify-between items-center">
  <p class="mt-0 text-sm">
    TH ↔ Þ
  </p>
  <p class="flex items-center mt-0">
    
      <a class="icon mx-2" href="https://github.com/agaura" title="github">
      
        <svg fill="#63636f" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="https://www.instagram.com/arg793/" title="instagram">
      
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill = "#bc2a8d" d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="https://www.linkedin.com/in/alexander-gaura-19980514a/" title="linkedin">
      
        <svg fill="#0073b1" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="/index.xml" title="rss">
      
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill = "#ee802f" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg>
      
      </a>
    
  </p>
</footer>
</body>
</html>