<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:url" content="https://agaura.github.io/smokestream/">
  <meta property="og:site_name" content="Alexander Gaura">
  <meta property="og:title" content="Smokestream">
  <meta property="og:description" content="Introduction In the background of this page you can see an invisible sprite leaving a trail of multi-colored “smoke.” Feel free to click and drag on the page itself, your cursor will also give off colored smoke. The experience works in both light and dark mode but is best viewed in dark mode, so click the ⚪️/⚫️ button to switch. Scroll down for an empty area to interact with the smoke and for information on the settings.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2023-03-15T15:58:16-04:00">
    <meta property="article:modified_time" content="2023-03-15T15:58:16-04:00">
    <meta property="article:tag" content="Shader">
    <meta property="article:tag" content="Dither">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Smokestream">
  <meta name="twitter:description" content="Introduction In the background of this page you can see an invisible sprite leaving a trail of multi-colored “smoke.” Feel free to click and drag on the page itself, your cursor will also give off colored smoke. The experience works in both light and dark mode but is best viewed in dark mode, so click the ⚪️/⚫️ button to switch. Scroll down for an empty area to interact with the smoke and for information on the settings.">

  
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-BBWS173BMQ"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-BBWS173BMQ');
        }
      </script>
    
  


  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#262d33">
  <title>
    
    Alexander Gaura - Smokestream
    
  </title>
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap"
    rel="stylesheet">
  
  
  
  <link rel="stylesheet" href="/minima.1742167080.css">

  
  
  <script defer type="text/javascript" src="/minima.1742167080.js"></script>
</head>
<script>
  
  let theme_2b_used = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

  try {
    if (!('theme' in localStorage)) {
      const default_theme = 'system';
      
      
      if (default_theme === 'dark' || default_theme === 'light') {
        theme_2b_used = default_theme;
      }

      
      localStorage.theme = theme_2b_used;
    }
    
    document.querySelector('html').classList.add(localStorage.theme);
  } catch (e) {
    console.error(e);
  }
</script>


<body class=" sm:mx-5 sm:my-0">
  <header class="flex justify-between items-center mb-6 sm:my-3">
  <div class="flex items-center">
    
    <div id="theme-switcher" class="text-4xl cursor-pointer">⚫️</div>
  </div>
  <nav class="flex items-center
    whitespace-nowrap overflow-x-auto overflow-y-hidden">
    
    <a class="ml-5" href="/">Home</a>
    
    <a class="ml-5" href="/categories/writing">Writing</a>
    
    <a class="ml-5" href="/categories/projects">Projects</a>
    
    <a class="ml-5" href="/about">About</a>
    
  </nav>
</header>
  
  

<h1 class="mt-6 mb-6">Smokestream</h1>
<div class="mb-3 text-xs flex justify-between sm:flex-col">
	<div>
	
		Posted at &mdash; Mar 15, 2023
	
		
	</div>
	
	<div class="sm:mt-4">
		
		<a class="not-first:ml-3" href="/tags/shader">#shader</a>
		
		<a class="not-first:ml-3" href="/tags/dither">#dither</a>
		
	</div>
	
</div>
<main>
	<p></p>
	<article class="md">
		<h1 id="introduction">Introduction</h1>
<p>  In the background of this page you can see an invisible sprite leaving a trail of multi-colored “smoke.” Feel free to click and drag on the page itself, your cursor will also give off colored smoke. The experience works in both light and dark mode but is best viewed in dark mode, so click the ⚪️/⚫️ button to switch. Scroll down for an empty area to interact with the smoke and for information on the settings.</p>
<p>  <span style="color:red"><b>Caution</b></span>: If there is any lag, move the bottom slider to the right. However, if you have a fast computer, best high-definition results come from moving the bottom slider to the left.</p>
<p>  Note: All settings can also be toggled by pressing on the keyboard key that matches the first letter of the setting.</p>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>    <!-- topojson -->
<script src="https://unpkg.com/topojson@3"></script>    <!-- WebGL -->
<script src="https://webgl2fundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://unpkg.com/jquery@3.5.1"></script>
<p><b style="font-size:30px" id='btn' onmouseover="this.style.cursor='pointer';" width = 20px>⏸</b>
<canvas id="canvas" style='position:fixed; left:0; top:0; z-index: -1;'></canvas></p>
<script type = "text" id = "vertex">
// an attribute is an input (in) to a vertex shader.
// It will receive data from a buffer
in vec2 a_position;
in vec2 a_texCoord;
uniform vec2 u_resolution;
out vec2 v_texCoord;
void main() {
    vec2 zeroToOne = a_position / u_resolution;
    vec2 zeroToTwo = zeroToOne * 2.0; // convert from 0->1 to 0->2
    vec2 clipSpace = zeroToTwo - 1.0; // convert from 0->2 to -1->+1 (clipspace)
    gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1); // pass the texCoord to the fragment shader
v_texCoord = a_texCoord;
}
</script>
<script type = "text" id = "colors">
// Copyright(c) 2021 Björn Ottosson
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this softwareand associated documentation files(the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions :
// The above copyright noticeand this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#define M_PI 3.1415926535897932384626433832795
float cbrt( float x )
{
    return sign(x)*pow(abs(x),1.0f/3.0f);
}

float srgb_transfer_function(float a)
{
    return .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;
}

float srgb_transfer_function_inv(float a)
{
    return .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;
}

vec3 linear_srgb_to_oklab(vec3 c)
{
    float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;
    float m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;
    float s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;	float l_ = cbrt(l);
    float m_ = cbrt(m);
    float s_ = cbrt(s);	return vec3(
        0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,
        1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,
        0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_
    );
}

vec3 oklab_to_linear_srgb(vec3 c)
{
    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;
    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;
    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;	float l = l_ * l_ * l_;
    float m = m_ * m_ * m_;
    float s = s_ * s_ * s_;	return vec3(
        +4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,
        -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,
        -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s
    );
}

// Finds the maximum saturation possible for a given hue that fits in sRGB
// Saturation here is defined as S = C/L
// a and b must be normalized so a^2 + b^2 == 1
float compute_max_saturation(float a, float b)
{
    // Max saturation will be when one of r, g or b goes below zero.	// Select different coefficients depending on which component goes below zero first
    float k0, k1, k2, k3, k4, wl, wm, ws;	if (-1.88170328f * a - 0.80936493f * b > 1.f)
    {
        // Red component
        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;
        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;
    }
    else if (1.81444104f * a - 1.19445276f * b > 1.f)
    {
        // Green component
        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;
        wl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;
    }
    else
    {
        // Blue component
        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;
        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;
    }
    
    // Approximate max saturation using a polynomial:
    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;	// Do one step Halley's method to get closer
    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
    // this should be sufficient for most applications, otherwise do two/three steps
    float k_l = +0.3963377774f * a + 0.2158037573f * b;
    float k_m = -0.1055613458f * a - 0.0638541728f * b;
    float k_s = -0.0894841775f * a - 1.2914855480f * b;	{
        float l_ = 1.f + S * k_l;
        float m_ = 1.f + S * k_m;
        float s_ = 1.f + S * k_s;
        float l = l_ * l_ * l_;
        float m = m_ * m_ * m_;
        float s = s_ * s_ * s_;
        float l_dS = 3.f * k_l * l_ * l_;
        float m_dS = 3.f * k_m * m_ * m_;
        float s_dS = 3.f * k_s * s_ * s_;
        float l_dS2 = 6.f * k_l * k_l * l_;
        float m_dS2 = 6.f * k_m * k_m * m_;
        float s_dS2 = 6.f * k_s * k_s * s_;
        float f = wl * l + wm * m + ws * s;
        float f1 = wl * l_dS + wm * m_dS + ws * s_dS;
        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
        S = S - f * f1 / (f1 * f1 - 0.5f * f * f2);
    }	return S;
}

// finds L_cusp and C_cusp for a given hue
// a and b must be normalized so a^2 + b^2 == 1
vec2 find_cusp(float a, float b)
{
    // First, find the maximum saturation (saturation S = C/L)
    float S_cusp = compute_max_saturation(a, b);	// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    vec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));
    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));
    float C_cusp = L_cusp * S_cusp;	return vec2( L_cusp , C_cusp );
}

// Finds intersection of the line defined by 
// L = L0 * (1 - t) + t * L1;
// C = t * C1;
// a and b must be normalized so a^2 + b^2 == 1
float find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)
{
    // Find the intersection for upper and lower half seprately
    float t;
    if (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)
    {
        // Lower half	
        t = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));
    }
    else
    {
        // Upper half		// First intersect with triangle
        t = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));		// Then one step Halley's method
        {
            float dL = L1 - L0;
            float dC = C1;
            float k_l = +0.3963377774f * a + 0.2158037573f * b;
            float k_m = -0.1055613458f * a - 0.0638541728f * b;
            float k_s = -0.0894841775f * a - 1.2914855480f * b;
            float l_dt = dL + dC * k_l;
            float m_dt = dL + dC * k_m;
            float s_dt = dL + dC * k_s;
            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            {
                float L = L0 * (1.f - t) + t * L1;
                float C = t * C1;
                float l_ = L + C * k_l;
                float m_ = L + C * k_m;
                float s_ = L + C * k_s;
                float l = l_ * l_ * l_;
                float m = m_ * m_ * m_;
                float s = s_ * s_ * s_;
                float ldt = 3.f * l_dt * l_ * l_;
                float mdt = 3.f * m_dt * m_ * m_;
                float sdt = 3.f * s_dt * s_ * s_;
                float ldt2 = 6.f * l_dt * l_dt * l_;
                float mdt2 = 6.f * m_dt * m_dt * m_;
                float sdt2 = 6.f * s_dt * s_dt * s_;
                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;
                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;
                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;
                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);
                float t_r = -r * u_r;
                float g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;
                float g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;
                float g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;
                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);
                float t_g = -g * u_g;
                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;
                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;
                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;
                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);
                float t_b = -b * u_b;
                t_r = u_r >= 0.f ? t_r : 10000.f;
                t_g = u_g >= 0.f ? t_g : 10000.f;
                t_b = u_b >= 0.f ? t_b : 10000.f;
                t += min(t_r, min(t_g, t_b));
            }
        }
    }	return t;
}

float find_gamut_intersection(float a, float b, float L1, float C1, float L0)
{
    // Find the cusp of the gamut triangle
    vec2 cusp = find_cusp(a, b);
    return find_gamut_intersection(a, b, L1, C1, L0, cusp);
}

vec3 gamut_clip_preserve_chroma(vec3 rgb)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float L0 = clamp(L, 0.f, 1.f);	float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;
    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_project_to_0_5(vec3 rgb)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float L0 = 0.5;	float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;
    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_project_to_L_cusp(vec3 rgb)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
    vec2 cusp = find_cusp(a_, b_);	float L0 = cusp.x;	float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;
    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float Ld = L - 0.5f;
    float e1 = 0.5f + abs(Ld) + alpha * C;
    float L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));
    float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);	float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
    vec2 cusp = find_cusp(a_, b_);	float Ld = L - cusp.x;
    float k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);	float e1 = 0.5f * k + abs(Ld) + alpha * C / k;
    float L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));
    float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

float toe(float x)
{
    float k_1 = 0.206f;
    float k_2 = 0.03f;
    float k_3 = (1.f + k_1) / (1.f + k_2);
    return 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));
}

float toe_inv(float x)
{
    float k_1 = 0.206f;
    float k_2 = 0.03f;
    float k_3 = (1.f + k_1) / (1.f + k_2);
    return (x * x + k_1 * x) / (k_3 * (x + k_2));
}

vec2 to_ST(vec2 cusp)
{
    float L = cusp.x;
    float C = cusp.y;
    return vec2( C / L, C / (1.f - L) );
}

// Returns a smooth approximation of the location of the cusp
// This polynomial was created by an optimization process
// It has been designed so that S_mid < S_max and T_mid < T_max

vec2 get_ST_mid(float a_, float b_)
{
    float S = 0.11516993f + 1.f / (
        +7.44778970f + 4.15901240f * b_
        + a_ * (-2.19557347f + 1.75198401f * b_
            + a_ * (-2.13704948f - 10.02301043f * b_
                + a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_
                    )))
        );
        float T = 0.11239642f + 1.f / (
            +1.61320320f - 0.68124379f * b_
            + a_ * (+0.40370612f + 0.90148123f * b_
                + a_ * (-0.27087943f + 0.61223990f * b_
                    + a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_
                    )))
     );	return vec2( S, T );
}

vec3 get_Cs(float L, float a_, float b_)
    {
    vec2 cusp = find_cusp(a_, b_);	float C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);
    vec2 ST_max = to_ST(cusp);
    // Scale factor to compensate for the curved part of gamut shape:
    float k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);
    float C_mid;
    {
        vec2 ST_mid = get_ST_mid(a_, b_);		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        float C_a = L * ST_mid.x;
        float C_b = (1.f - L) * ST_mid.y;
        C_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));
    }
    float C_0;
    {
     // for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.
        float C_a = L * 0.4f;
        float C_b = (1.f - L) * 0.8f;		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        C_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));
    }	return vec3( C_0, C_mid, C_max );
}

vec3 okhsl_to_srgb(vec3 hsl)
{
    float h = hsl.x;
    float s = hsl.y;
    float l = hsl.z;
    if (l == 1.0f)
    {
        return vec3( 1.f, 1.f, 1.f );
    }
    else if (l == 0.f)
    {
        return vec3( 0.f, 0.f, 0.f );
    }
 	float a_ = cos(2.f * M_PI * h);
    float b_ = sin(2.f * M_PI * h);
    float L = toe_inv(l);
    vec3 cs = get_Cs(L, a_, b_);
    float C_0 = cs.x;
    float C_mid = cs.y;
    float C_max = cs.z;
    float mid = 0.8f;
    float mid_inv = 1.25f;	float C, t, k_0, k_1, k_2;
    if (s < mid)
    {
        t = mid_inv * s;
        k_1 = mid * C_0;
        k_2 = (1.f - k_1 / C_mid);
        C = t * k_1 / (1.f - k_2 * t);
    }
    else
    {
        t = (s - mid)/ (1.f - mid);
        k_0 = C_mid;
        k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
        k_2 = (1.f - (k_1) / (C_max - C_mid));
        C = k_0 + t * k_1 / (1.f - k_2 * t);
    }
 
    vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));
    return vec3(
        srgb_transfer_function(rgb.r),
        srgb_transfer_function(rgb.g),
        srgb_transfer_function(rgb.b)
    );
}

vec3 srgb_to_okhsl(vec3 rgb)
{
    vec3 lab = linear_srgb_to_oklab(vec3(
        srgb_transfer_function_inv(rgb.r),
        srgb_transfer_function_inv(rgb.g),
        srgb_transfer_function_inv(rgb.b)
    ));
    float C = sqrt(lab.y * lab.y + lab.z * lab.z);
    float a_ = lab.y / C;
    float b_ = lab.z / C;
    float L = lab.x;
    float h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;
    vec3 cs = get_Cs(L, a_, b_);
    float C_0 = cs.x;
    float C_mid = cs.y;
    float C_max = cs.z;	// Inverse of the interpolation in okhsl_to_srgb:
    float mid = 0.8f;
    float mid_inv = 1.25f;	float s;
    if (C < C_mid)
    {
        float k_1 = mid * C_0;
        float k_2 = (1.f - k_1 / C_mid);
        float t = C / (k_1 + k_2 * C);
        s = t * mid;
    }
    else
    {
        float k_0 = C_mid;
        float k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
        float k_2 = (1.f - (k_1) / (C_max - C_mid));
        float t = (C - k_0) / (k_1 + k_2 * (C - k_0));
        s = mid + (1.f - mid) * t;
    }
    float l = toe(L);
    return vec3( h, s, l );
}

vec3 okhsv_to_srgb(vec3 hsv)
{
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;
    float a_ = cos(2.f * M_PI * h);
    float b_ = sin(2.f * M_PI * h);
    vec2 cusp = find_cusp(a_, b_);
    vec2 ST_max = to_ST(cusp);
    float S_max = ST_max.x;
    float T_max = ST_max.y;
    float S_0 = 0.5f;
    float k = 1.f- S_0 / S_max;	// first we compute L and V as if the gamut is a perfect triangle:	// L, C when v==1:
    float L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);
    float C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);
    float L = v * L_v;
    float C = v * C_v;	// then we compensate for both toe and the curved top part of the triangle:
    float L_vt = toe_inv(L_v);
    float C_vt = C_v * L_vt / L_v;	float L_new = toe_inv(L);
    C = C * L_new / L;
    L = L_new;	vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));
    float scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));
    L = L * scale_L;
    C = C * scale_L;	vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));
    return vec3(
        srgb_transfer_function(rgb.r),
        srgb_transfer_function(rgb.g),
        srgb_transfer_function(rgb.b)
    );
}

vec3 srgb_to_okhsv(vec3 rgb)
{
    vec3 lab = linear_srgb_to_oklab(vec3(
        srgb_transfer_function_inv(rgb.r),
        srgb_transfer_function_inv(rgb.g),
        srgb_transfer_function_inv(rgb.b)
    ));
    float C = sqrt(lab.y * lab.y + lab.z * lab.z);
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float L = lab.x;
    float h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;
    vec2 cusp = find_cusp(a_, b_);
    vec2 ST_max = to_ST(cusp);
    float S_max = ST_max.x;
    float T_max = ST_max.y;
    float S_0 = 0.5f;
    float k = 1.f - S_0 / S_max;	// first we find L_v, C_v, L_vt and C_vt
    float t = T_max / (C + L * T_max);
    float L_v = t * L;
    float C_v = t * C;	float L_vt = toe_inv(L_v);
    float C_vt = C_v * L_vt / L_v;	// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
    vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));
    float scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));
    L = L / scale_L;
    C = C / scale_L;
    C = C * toe(L) / L;
    L = toe(L);	// we can now compute v and s:
    float v = L / L_v;
    float s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);	return vec3 (h, s, v );
}

vec3 hsl2rgb( in vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
}

vec3 rgb2hsl( in vec3 c ){
float h = 0.0;
    float s = 0.0;
    float l = 0.0;
    float r = c.r;
    float g = c.g;
    float b = c.b;
    float cMin = min( r, min( g, b ) );
    float cMax = max( r, max( g, b ) );	l = ( cMax + cMin ) / 2.0;
    if ( cMax > cMin ) {
        float cDelta = cMax - cMin;
        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original
        s = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );
        if ( r == cMax ) {
            h = ( g - b ) / cDelta;
        } else if ( g == cMax ) {
            h = 2.0 + ( b - r ) / cDelta;
        } else {
            h = 4.0 + ( r - g ) / cDelta;
        }		if ( h < 0.0) {
            h += 6.0;
        }
        h = h / 6.0;
    }
    return vec3( h, s, l );
}

bool inDither( float h, float antiHue, float antiRad) {
    return (((h > antiHue - antiRad) && (h < antiHue + antiRad))) ||
    (((h - 1.0f > antiHue - antiRad) && (h - 1.0f < antiHue + antiRad))) ||
    (((1.0f + h > antiHue - antiRad) && (1.0f + h < antiHue + antiRad)));
}

float dither( float h, float r, float antiHue, float antiRad) {
    float rightBound = antiHue - antiRad;
    if (rightBound < -0.5f) rightBound = rightBound + 1.0f;
    float leftBound = antiHue + antiRad;
    if (leftBound > 0.5f) leftBound = leftBound - 1.0f;
    if ((h > antiHue - antiRad) && (h < antiHue + antiRad))
        if (((h - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
            h = rightBound;
        else h = leftBound;
    else if ((h - 1.0f > antiHue - antiRad) && (h - 1.0f < antiHue + antiRad))
        if (((h - 1.0f - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
         h = rightBound;
        else h = leftBound;
    else if ((1.0f + h > antiHue - antiRad) && (1.0f + h < antiHue + antiRad))
        if (((1.0f + h - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
            h = rightBound;
        else h = leftBound;
    return h;
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

//const vec3 wref =  vec3(.950456, 1.0, 1.089058); 
const vec3 wref =  vec3(1.0, 1.0, 1.0);

float xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }

vec3 lch2rgb(in vec3 c)
{
    c = vec3(c.x, cos(c.z) * c.y, sin(c.z) * c.y);
    float lg = 1./116.*(c.x + 16.);
    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),
    				wref.y*xyzR(lg),
    				wref.z*xyzR(lg - 0.005*c.z));
    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,
          		        -0.9689,  1.8758, 0.0415,
                	     0.0557,  -0.2040, 1.0570);
    return rgb;
}

vec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {
    return (line1y - line2y) / (line2x - line1x);
}

vec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {
    return sqrt(pointx*pointx + pointy*pointy);
}

vec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {
    vec3 len = y / (sin(theta) - x * cos(theta));
    if (len.r < 0.0) {len.r=1000.0;}
    if (len.g < 0.0) {len.g=1000.0;}
    if (len.b < 0.0) {len.b=1000.0;}
    return len;
}

float hsluv_maxSafeChromaForL(float L){
    mat3 m2 = mat3(
         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,
        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,
        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  
    );
    float sub0 = L + 16.0;
    float sub1 = sub0 * sub0 * sub0 * .000000641;
    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;
    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;
    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;
    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;
    vec3 bounds0x = top1 / bottom;
    vec3 bounds0y = top2 / bottom;
    vec3 bounds1x =              top1 / (bottom+126452.0);
    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);
    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );
    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );
    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );
    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );
    return  min(lengths0.r,
            min(lengths1.r,
            min(lengths0.g,
            min(lengths1.g,
            min(lengths0.b,
                lengths1.b)))));
}

float hsluv_maxChromaForLH(float L, float H) {
    float hrad = radians(H);
    mat3 m2 = mat3(
         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,
        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,
        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  
    );
    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;
    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;
    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;
    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;
    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;
    vec3 bound0x = top1 / bottom;
    vec3 bound0y = top2 / bottom;
    vec3 bound1x =              top1 / (bottom+126452.0);
    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);
    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );
    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );
    return  min(lengths0.r,
            min(lengths1.r,
            min(lengths0.g,
            min(lengths1.g,
            min(lengths0.b,
                lengths1.b)))));
}

float hsluv_fromLinear(float c) {
    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;
}

vec3 hsluv_fromLinear(vec3 c) {
    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );
}

float hsluv_toLinear(float c) {
    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;
}

vec3 hsluv_toLinear(vec3 c) {
    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );
}

float hsluv_yToL(float Y){
    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;
}

float hsluv_lToY(float L) {
    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);
}

vec3 xyzToRgb(vec3 tuple) {
    const mat3 m = mat3( 
        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,
       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,
        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );
    return hsluv_fromLinear(tuple*m);
}

vec3 rgbToXyz(vec3 tuple) {
    const mat3 m = mat3(
        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,
        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,
        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 
    );
    return hsluv_toLinear(tuple) * m;
}

vec3 xyzToLuv(vec3 tuple){
    float X = tuple.x;
    float Y = tuple.y;
    float Z = tuple.z;
    float L = hsluv_yToL(Y);
    float div = 1./dot(tuple,vec3(1,15,3)); 
    return vec3(
        1.,
        (52. * (X*div) - 2.57179),
        (117.* (Y*div) - 6.08816)
    ) * L;
}

vec3 luvToXyz(vec3 tuple) {
    float L = tuple.x;
    float U = tuple.y / (13.0 * L) + 0.19783000664283681;
    float V = tuple.z / (13.0 * L) + 0.468319994938791;
    float Y = hsluv_lToY(L);
    float X = 2.25 * U * Y / V;
    float Z = (3./V - 5.)*Y - (X/3.);
    return vec3(X, Y, Z);
}

vec3 luvToLch(vec3 tuple) {
    float L = tuple.x;
    float U = tuple.y;
    float V = tuple.z;
    float C = length(tuple.yz);
    float H = degrees(atan(V,U));
    if (H < 0.0) {
        H = 360.0 + H;
    }
    return vec3(L, C, H);
}

vec3 lchToLuv(vec3 tuple) {
    float hrad = radians(tuple.b);
    return vec3(
        tuple.r,
        cos(hrad) * tuple.g,
        sin(hrad) * tuple.g
    );
}

vec3 hsluvToLch(vec3 tuple) {
    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;
    return tuple.bgr;
}

vec3 lchToHsluv(vec3 tuple) {
    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;
    return tuple.bgr;
}

vec3 hpluvToLch(vec3 tuple) {
    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;
    return tuple.bgr;
}

vec3 lchToHpluv(vec3 tuple) {
    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;
    return tuple.bgr;
}

vec3 lchToRgb(vec3 tuple) {
    return xyzToRgb(luvToXyz(lchToLuv(tuple)));
}

vec3 rgbToLch(vec3 tuple) {
    return luvToLch(xyzToLuv(rgbToXyz(tuple)));
}

vec3 hsluvToRgb(vec3 tuple) {
    return lchToRgb(hsluvToLch(tuple));
}

vec3 rgbToHsluv(vec3 tuple) {
    return lchToHsluv(rgbToLch(tuple));
}

vec3 hpluvToRgb(vec3 tuple) {
    return lchToRgb(hpluvToLch(tuple));
}

vec3 rgbToHpluv(vec3 tuple) {
    return lchToHpluv(rgbToLch(tuple));
}

vec3 luvToRgb(vec3 tuple){
    return xyzToRgb(luvToXyz(tuple));
}
</script>
<script type = "text" id = "advection">
uniform float deltaT; // this one is really just the frame rate
uniform float dt; // the actual deltaT
uniform sampler2D u_image;
uniform sampler2D velocity;
uniform bool mouseDown;
uniform bool paint;
uniform bool dark;
uniform vec2 change;
uniform vec2 center;
uniform vec2 radius;
uniform float time;
uniform bool glitter;
uniform bool toggle;
uniform float initialDirection;

uniform vec2 spriteChange;
uniform vec2 spriteCenter;

in vec2 v_texCoord;
out vec4 outColor;

// for future, we can try to add a uniform that represents the background color of the page

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

vec2 scale(vec2 val) {

    // these two values technically effect each other, so play around with it to get ideal results
    float highValStrength = 0.57; // should be less than 1
    float lowValStrength = 250.0; // should be large
    return sign(val) * pow(lowValStrength * abs(val), vec2(highValStrength)) / lowValStrength;
}

vec2 scale2(vec2 val) {

    // these two values technically effect each other, so play around with it to get ideal results
    return sign(val) * (1.0 - pow(1.0 - abs(val), vec2(60.0))) / 45.0;
}

vec2 scale3(vec2 val) {

    // these two values technically effect each other, so play around with it to get ideal results
    return sign(val) * (1.0 - pow(1.0 - abs(val), vec2(100.0))) / 45.0;
}

vec3 closestPoint(vec2 delta, vec2 end, vec2 current) {

    if (delta == vec2(0.0)) {return vec3(end, 0.0);}

    else {
        vec2 initial = end - delta;
        float t = clamp(dot(current - initial, delta) / (delta.x * delta.x + delta.y * delta.y), 0.0, 1.0);
        vec2 closest = initial + t * delta;
        //vec2 closest = initial + t * delta + sin(t * 6.*M_PI) * vec2(-delta.y, delta.x); // kinda freaky, looks centipede-like

        return vec3(closest, t);
    }
    
}

float spread(float val, float mag) {
    if (val < 0.5) {
        val = pow(val * 2.0, mag) / 2.0;
    }
    else {
        val = 1.0 - pow((1.0 - val) * 2.0, mag) / 2.0;
    }
    return val;
}

void main() {

    vec4 result = texture(u_image, v_texCoord);

    float ratio = radius.y / radius.x;

    if (toggle || !mouseDown) {

        vec2 u = texture(velocity, v_texCoord).xy;
        //vec2 pastCoord = fract(v_texCoord - (0.5 * deltaT * u));
        vec2 pastCoord = fract(v_texCoord - (0.5 * deltaT * u * vec2(1./ratio, 1.0)));
        result = texture(u_image, pastCoord);
    }

    outColor = result;

    if (paint) {

        if (mouseDown) {

            // sees how close a pixel is to the closest point on the line traced by the last two points registered from the cursor
            vec3 closest = closestPoint(change, center, v_texCoord);
            vec2 close = closest.xy;
            float t = closest.z;
            float dx = (close.x - v_texCoord.x) * ratio;
            float dy = (close.y - v_texCoord.y); // dy = 0.; // interesting effect

            // idle click effect
            if (change == vec2(0.0)) {
                vec2 effect = 50. * scale3(vec2(0.001)) * exp(-(dx * dx + dy * dy) / .001);
                float mag = (effect.x * effect.x + effect.y * effect.y) / 2.0;
                //vec4 newColor = vec4(hsl2rgb(vec3(time / 17.0, 1.0, 0.5)), 1.0); // oil slick color
                vec4 newColor = vec4(hsl2rgb(vec3(time/3333., 1.0, 0.5)), 1.0);
                //vec4 newColor = vec4(hsl2rgb(vec3(time / 17.0, 1.0, 0.5)), 1.0); // oil slick color, looks great with a small radius
                if (dark) {result = result + newColor * mag;}
                else {result = mix(result, newColor, mag);}
            }

            else {

                // find out how affected a pixel should be due to its distance as well as the velocity (numbers chosen by experimentation)
                vec2 effect = 50. * scale2(change) * exp(-(dx * dx + dy * dy) / (.001 * mix(1., 10., length(change))));
                //effect = 50. * (scale2(change) + vec2(0.0,-0.005)) * exp(-(dx * dx + dy * dy) / (radius * .5)); // for the aurora
                //effect = 50. * (scale2(change) + vec2(0.0,-0.002)) * exp(-(dx * dx + dy * dy) / (radius * .5)); // gives an interesting effect
                float mag = (effect.x * effect.x + effect.y * effect.y) / 2.0;

                // determine the color
                vec4 color = vec4(0.3,0.,1.,1.0); // make a random color
                //color = vec4(okhsl_to_srgb(vec3(time / 1024.0, 1.0, 0.5)), 1.0); // gentle and smooth rainbow (original)
                //color = vec4(hsl2rgb(vec3(time / 1024.0 + (time + t * dt) * mag / (2.* 8192.0), 0.25, 0.5)), 1.0); // reaaaally cool oil slick
                //color = vec4(okhsl_to_srgb(vec3((time + t) / 1024.0 + 0.9 * pow(mag, 0.5), 0.9, 0.5)), 1.0); // reaaaally cool oil slick
                //color = vec4(okhsl_to_srgb(vec3((time + t) / 20000.0 + 0.5 * pow(mag, 0.5), 1.0, 0.5 + 0.1 * sin(dx*dy*10000.*3.))), 1.0); // this one is just slow
                //color = vec4(okhsl_to_srgb(vec3(atan(dy, dx) / (2. * M_PI) + 0.9 * pow(mag, 0.5), 0.9, 0.5 + 0.1 * sin(dx*dy*10000.*3.))), 1.0); // very pretty, might be useful for debugging
                if (initialDirection > 0.005) {
                    float exactHue = initialDirection + 0.5 * pow(mag, 0.5);
                    color = vec4(okhsl_to_srgb(vec3(exactHue, 1.0, 0.1 * (1.0 - float(dark)) + 0.5 + 0.15 * sin(dx*dy*10000.*3.))), 1.0); // control color by direction

                    // getting rid of green
                    /*if ((exactHue > 0.33) && (exactHue < 0.42)){
                        color = vec4(okhsl_to_srgb(vec3(exactHue, 0.0, 0.1 * (1.0 - float(dark)) + 0.5 + 0.15 * sin(dx*dy*10000.*3.))), 1.0); // control color by direction
                    }*/
                }
                else {
                    float addon = 0.0;
                    if ((change.y != 0.) || (change.x != 0.)) {addon = atan(change.y, change.x) / (2. * M_PI);}
                    color = vec4(okhsl_to_srgb(vec3(addon + 0.5 * pow(mag, 0.5), 1.0, 0.1 * (1.0 - float(dark)) + 0.5 + 0.15 * sin(dx*dy*10000.*3.))), 1.0); // control color by direction
                }
                //color = vec4(okhsl_to_srgb(vec3((time + t) / (1024.0 * 1. * pow(change.x * change.y, 0.05) + 16.) + 0.9 * pow(mag, 0.5), 0.9, 0.5)), 1.0); // trying to make it cycle through more colors when slow, so that when it's real slow it'll effectively be gray 

                // if dark mode is on, add the color to the background, which will cause brightening (like a glow)
                if (dark) {result = result + mix(vec4(0.0), color, mag);} // if you want to add summing-to-white effects

                // colors are mixed in light mode as it seems more natural (kinda like subtractive color mixing)
                else {result = mix(result, color, mag);}

                //result = vec4(0.1*sin(close * 200000.0), 0.0, 0.99); // really useful
                //result = vec4(0.1*cos((close - 1.0) * 100.0), 0.0, 0.99); // really useful
                //result = vec4((ratio - 1.) * 125., - (ratio - 1.) * 125., 0.0, 0.99);
                //result = vec4(hsl2rgb(vec3(1.0, (ratio - 1.), 0.5)), 1.0);
                //if (dx*dx < 0.001) {if (dy*dy < 0.001) {result = vec4(.5, 0., 0., 0.5);}}
                //if (sqrt(dx*dx +dy*dy) < 0.03) {result = vec4(.5, 0., 0., 0.5);}
            }
        }

        if (toggle) {
        float dxp = (spriteCenter.x - v_texCoord.x) * ratio;
        float dyp = spriteCenter.y - v_texCoord.y;
        
        vec2 effectp = 50. * scale3(spriteChange) * exp(-(dxp * dxp + dyp * dyp) / .001);
        float magp = (effectp.x * effectp.x + effectp.y * effectp.y) / 2.0;
        //vec4 newColor = vec4(hsl2rgb(vec3(time / 17.0, 1.0, 0.5)), 1.0); // oil slick color
        //vec4 newColor = vec4(hsl2rgb(vec3(time/1024., 1.0, 0.5)), 1.0);
        vec4 newColor = vec4(hsl2rgb(vec3(time / 17.0, 1.0, 0.5)), 1.0); // oil slick color, looks great with a small radius
        if (dark) {result = result + newColor * magp;}
        else {result = mix(result, newColor, magp);}
        //result = mix(vec4(0.0), result, 0.98 + 0.02 * clamp(length(u),0.,1.));
        //result = mix(vec4(0.0), result, pow(result.a, 0.001) - 0.02);
        //result = mix(vec4(0.0), result, pow(result.a, 0.001) - 0.02 + 0.02 * clamp(length(u),0.,1.));
        result = mix(vec4(0.0), result, 0.995);
        }

        // something along these lines could be helpful for keeping colors saturated while they fade away
        /*
        if (v_texCoord.y > 0.5) {
            vec3 xxx = srgb_to_okhsl(clamp(result.rgb,0.0,1.0));

            if (result.a > xxx.g) {
                result = vec4(okhsl_to_srgb(vec3(xxx.r,mix(xxx.g,0.95,0.1),xxx.b)), result.a);
            }
            else {
                result = vec4(okhsl_to_srgb(vec3(xxx.r,mix(xxx.g,0.95,1.0),xxx.b)), result.a);
            }
        }*/
                
        if (glitter) {
            vec4 xxx = vec4(srgb_to_okhsl(clamp(result.rgb,0.0,1.0)),clamp(result.a,0.0,1.0));

            float zzz = rand(vec2(v_texCoord.x * 10. + v_texCoord.y, time /100000.));

            if (zzz > 0.975) { // 0.925 looks reeeeaaaally cool when in HD
            // if (zzz > 0.875 + 0.1 * (1.0 - pow(xxx.a,1.0))) { // experiment with this one
                if (xxx.b < 0.99) { // prevents weird black dots
                    xxx.b = mix(xxx.b, mix(pow(xxx.b,2.),.99,pow(xxx.a,.75)), 0.5);
                }
                // xxx.b = mix(xxx.b, max(0.0, 0.1 * ((1.0 - zzz) * 40. - .5) + mix(pow(xxx.b,2.),.99,pow(xxx.a,.75))), 0.5); // could be useful
                //xxx.b = mix(xxx.b, mix(-.5,.99,pow(xxx.a,.75)), 0.5); // really weird but interesting effect
                //xxx.g = mix(xxx.g,1.0,0.5*xxx.a);
                xxx.g = mix(xxx.g*0.9,1.0,pow(xxx.a,.75));
                xxx.r = xxx.r + 0.1 * (1.1 - pow(xxx.a,2.)) * ((1.0 - zzz) * 40. - 0.5);
            }

            result = vec4(okhsl_to_srgb(xxx.rgb), result.a);

        }

        outColor = clamp(result,0.0,1.0);

        //if ((result.a == 1.0)) {outColor = vec4(0.0);}
        //if ((result.a < 1.0)) {outColor = mix(vec4(0.0), result, 0.99);}

        //outColor = vec4(1.0*change,0.0,1.0);
        
    }
}
</script>
<script type = "text" id = "divergence">
uniform float deltaT;         // Time between steps
uniform float rho;            // Density
uniform vec2 epsilon;        // Distance between grid units
uniform sampler2D velocity;   // Advected velocity field, u_a
      
in vec2 v_texCoord; 
out vec4 outColor;
      
vec2 u(vec2 coord) { 
    return texture(velocity, fract(coord)).xy; 
} 

void main() { 
    outColor = vec4((-2.0 * epsilon.x * rho / deltaT) *  
        (u(v_texCoord + vec2(epsilon.x, 0)).x - 
        u(v_texCoord - vec2(epsilon.x, 0)).x) 
        +
        (-2.0 * epsilon.y * rho / deltaT) *
        (u(v_texCoord + vec2(0, epsilon.y)).y - 
        u(v_texCoord - vec2(0, epsilon.y)).y) 
        , 0.0, 0.0, 1.0); 

    //outColor = vec4(texture(velocity, v_texCoord).xy,0.0,1.0);
    //outColor = vec4((texture(velocity, v_texCoord).xy+1.0)/2.0,0.0,1.0);
    //outColor = vec4(texture(velocity, v_texCoord).xy+2.0,0.0,1.0);
}
</script>
<script type = "text" id = "jacobi">
uniform vec2 epsilon;        // Distance between grid units
uniform sampler2D divergence; // Divergence field of advected velocity, d
uniform sampler2D pressure;   // Pressure field from previous iteration, p^(k-1)
      
in vec2 v_texCoord; 
out vec4 outColor;
      
float d(vec2 coord) { 
    return texture(divergence, fract(coord)).x; 
} 
      
float p(vec2 coord) { 
    return texture(pressure, fract(coord)).x; 
}
      
void main() { 
    outColor = vec4(0.25 * (
        d(v_texCoord)
        + p(v_texCoord + vec2(2.0 * epsilon.x, 0.0))
        + p(v_texCoord - vec2(2.0 * epsilon.x, 0.0)) 
        + p(v_texCoord + vec2(0.0, 2.0 * epsilon.y)) 
        + p(v_texCoord - vec2(0.0, 2.0 * epsilon.y))
        ),0.0,0.0,1.0);
}
</script>
<script type = "text" id = "pressure">

#define M_PI 3.1415926535897932384626433832795

uniform float deltaT;         // Time between steps
uniform float rho;            // Density 
uniform vec2 epsilon;        // Distance between grid units 
uniform sampler2D velocity;   // Advected velocity field, u_a 
uniform sampler2D pressure;   // Solved pressure field 

uniform bool mouseDown;
uniform bool toggle;
uniform vec2 change;
uniform vec2 center;
uniform vec2 radius;

uniform vec2 spriteChange;
uniform vec2 spriteCenter;
      
in vec2 v_texCoord;
out vec4 outColor;
      
float p(vec2 coord) { 
    return texture(pressure, fract(coord)).x; 
} 

float rand(vec2 co) {
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

// THIS FUNCTION NEEDS TO BE UPDATED TO BE CONSIDERATE OF THE WINDOW'S DIMENSIONS!!! XXXXX
// actually I don't know if it does lol, think about it later

vec2 closestPoint(vec2 delta, vec2 end, vec2 current) {

    if (delta == vec2(0.0)) {return end;}

    else {

        vec2 initial = end - delta;
        float t = clamp(dot(current - initial, delta) / (delta.x * delta.x + delta.y * delta.y), 0.0, 1.0);
        //vec2 closest = initial + t * delta;
        vec2 closest = initial + t * delta + 1. * pow(length(change), 0.5) * (sin(t * 6. * M_PI) + 1.0 * (rand(vec2(t*100.0,deltaT))-0.5)) * 0.025 * normalize(vec2(-delta.y, delta.x)); // tbh I'm not sure if the rand adds anything of value

        return closest;
    }
    
}
      
void main() { 
    vec2 u_a = texture(velocity, v_texCoord).xy; 

    outColor = vec4(u_a, 0.0, 0.0);
        
    if (toggle || !mouseDown) {
        float diff_p_x = (p(v_texCoord + vec2(epsilon.x, 0.0)) - 
                          p(v_texCoord - vec2(epsilon.x, 0.0))); 
        float u_x = u_a.x - deltaT/(2.0 * rho * epsilon.x) * diff_p_x; 
        
        float diff_p_y = (p(v_texCoord + vec2(0.0, epsilon.y)) - 
                          p(v_texCoord - vec2(0.0, epsilon.y))); 
        float u_y = u_a.y - deltaT/(2.0 * rho * epsilon.y) * diff_p_y;
        outColor = vec4(u_x, u_y, 0.0, 0.0);
    }
        
    float ratio = epsilon.y / epsilon.x;

    if (mouseDown) {
        float dx = center.x - v_texCoord.x;
        float dy = center.y - v_texCoord.y;

        vec2 close = closestPoint(change, center, v_texCoord);
        dx = (close.x - v_texCoord.x) * ratio;
        dy = (close.y - v_texCoord.y);
        //outColor = outColor + vec4(25. * (change + vec2(0.0,-0.0025)) * exp(-(dx * dx + dy * dy) / (radius * 0.1)), 0.0, 1.0); // this could help for aurora
        //outColor = outColor + vec4(25. * change * vec2(1./ratio, 1.) * exp(-(dx * dx + dy * dy) / 0.00025), 0.0, 1.0);
        //outColor = outColor + vec4(25. * change * exp(-sqrt(dx * dx + dy * dy) / 0.01), 0.0, 1.0);
        outColor = outColor + vec4(25. * change * vec2(ratio, 1.) * exp(-sqrt(dx * dx + dy * dy) / 0.01), 0.0, 1.0);
    }

    if (toggle) {
        float dxp = (spriteCenter.x - v_texCoord.x) * ratio;
        float dyp = spriteCenter.y - v_texCoord.y;
        outColor = outColor + vec4(25. * spriteChange * exp(-(dxp * dxp + dyp * dyp) / (0.00025)), 0.0, 1.0);
    }
}
</script>
<script type = "text" id = "postprocess">
uniform sampler2D u_image;
uniform float time;
uniform int mode;
uniform vec2 epsilon;
in vec2 v_texCoord;
out vec4 outColor;

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

float interleavedGradientNoise(vec2 co){
    return fract(52.9829189 * (0.06711056 * co.x + 0.00583715 * co.y));
}

vec4 trigGradient(float co){
    float rot = cos(abs(co) * 128.);

    float neg_color_grad = rot * 0.04 + 0.11; // in okhsl, warm colors shift more rapidly than cool ones
    float pos_color_grad = rot * 0.08 + 0.68;

    float color_grad = 0.0;
    if (sign(co) > 0.) {color_grad = pos_color_grad;}
    else {color_grad = neg_color_grad;}

    float sat_grad = pow(clamp(abs(co * 8.),-1.,1.),0.5);
    float lum_grad = mix(0.5,0.8,clamp(abs(co * 2.),0.0,1.0));

    vec4 newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);

    vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    vec4 graycolor = vec4(okhsl_to_srgb(vec3(color_grad, 0.0, lum_grad)), 1.0);

    if (sign(co) > 0.) {newcolor = mix(vividcolor, graycolor, 0.0);}
    else {newcolor = mix(vividcolor, graycolor, 0.0);}

    float mix_strength = 0.0;
    if (sin(abs(co) * 128.) < 0.0) {mix_strength = (cos(M_PI * rot) * 0.5 + 0.5) * 0.5;}
    newcolor = mix(vividcolor, graycolor, mix_strength);

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 lineGradient(float co, float v, float sat_v, float lum_v){

    //float scale = pow(abs(co),.001);

    float travelled = fract(abs(co) * v) * 3.;
    //float travelled = fract(scale * v) * 3.;
    float mix_strength = fract(travelled);

    float sat_grad = pow(clamp(abs(co * sat_v),0.,1.),0.5);
    float lum_grad = mix(0.5,0.8,clamp(abs(co * lum_v),0.0,1.0));

    float neg_range = 0.10;
    float pos_range = 0.16;

    float neg_shift = 0.06;
    float pos_shift = 0.68;

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift;}
        else {color_grad = mix_strength * pos_range + 0.68;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift;}
        else {color_grad = - mix_strength * pos_range / 2.0 + pos_range + pos_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift;}
        else {color_grad = - mix_strength * pos_range / 2.0 + pos_range / 2.0 + pos_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 lineGradient2(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_grad = pow(clamp(scale / sat_band_limit,0.,1.),0.5);
    float lum_grad = mix(0.5,0.8,clamp(scale / lum_band_limit,0.0,1.0));

    float neg_range = 0.10;
    float pos_range = 0.16;

    float neg_shift = 0.90;
    float pos_shift = 0.68;

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift;}
        else {color_grad = mix_strength * pos_range + 0.68;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift;}
        else {color_grad = - mix_strength * pos_range / 2.0 + pos_range + pos_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift;}
        else {color_grad = - mix_strength * pos_range / 2.0 + pos_range / 2.0 + pos_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 lineGradient3(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_grad = pow(clamp(scale / sat_band_limit,0.,1.),0.85) * 0.85 + 0.15;
    float lum_grad = mix(0.3,0.75,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.5,0.65,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 1.) {
            lum_grad = mix(0.3,0.5,scale);
        }
    }
    if (scale < 1.) {
        sat_grad = mix(0.,0.15 + pow(1. / sat_band_limit,0.85) * 0.85, pow(scale,.33));
    }

    float neg_range = 0.12;
    float pos_range = 0.12;

    float neg_shift = 0.65;
    float pos_shift = 0.58;

    float pos_way = pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6);
    float pos_thresh = 2.0;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.45,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = - mix(0.5,0.,pos_way);}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(2. * scale / lum_band_limit,0.0,1.0),1.5);
    float neg_thresh = 8.0;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.2,(neg_way - 1.) / (neg_thresh - 1.));
    if (neg_way < 1.) {neg_hue_shift = mix(0.2,0.,neg_way);}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 lineGradient4(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }
    float lum_grad = mix(0.2,0.75,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.5,0.65,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.2,0.5,scale / 2.);
        }
    }
    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }

    float neg_range = 0.15;
    float pos_range = 0.15;

    float neg_shift = 0.5; // 0.8 is nice
    float pos_shift = 0.43;

    float pos_way = pow(clamp(1. * scale / lum_band_limit,0.0,1.0),0.5);
    float pos_thresh = 2.;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.33,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = mix(1.6,0.,pos_way);}
    //if (pos_way < 1.) {pos_hue_shift = - mix(0.4,0.,pow((pos_way-.5)*2.,1.));}
    //if (pos_way < .5) {pos_hue_shift = - mix(0.,0.4,pow(pos_way/.5,4.));}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(1.25 * scale / lum_band_limit,0.0,1.0),0.33);
    float neg_thresh = 2.;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.35,(neg_way - 1.) / (neg_thresh - 1.)); // 0.9 is nice with 0.8 neg_shift
    if (neg_way < 1.) {neg_hue_shift = mix(0.45,0.,pow(neg_way,4.));}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength * 0.5);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength * 0.5 + 0.5);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 edge(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).r;
    float right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).r;
    float left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).r;

    float avg = (upper + lower + right + left) / 4.;

    //float edge_grad = mix(0.,1.0,sign(co)*pow(clamp(100.*(abs(co-avg) / thresh) / lum_band_limit,0.0,1.0),2.)/2.0 + 0.5);
    float edge_grad = mix(0.,0.15,pow(clamp(1000.*(abs(co-avg) / thresh) / lum_band_limit,0.0,1.0),4.));

    

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }

    float lum_grad = mix(0.2,0.75,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.5,0.65,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.2,0.5,scale / 2.);
        }
    }
    lum_grad += 1. * edge_grad;

    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }
    sat_grad = clamp(sat_grad + clamp(1000.*edge_grad,0.0,pow(sat_grad,0.25)*0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(1000.*edge_grad,0.0,0.5),0.0,1.0);

    float neg_range = 0.15;
    float pos_range = 0.15;

    float neg_shift = 0.5; // 0.8 is nice
    float pos_shift = 0.43;

    float pos_way = pow(clamp(1. * scale / lum_band_limit,0.0,1.0),0.5);
    float pos_thresh = 2.;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.33,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = mix(1.6,0.,pos_way);}
    //if (pos_way < 1.) {pos_hue_shift = - mix(0.4,0.,pow((pos_way-.5)*2.,1.));}
    //if (pos_way < .5) {pos_hue_shift = - mix(0.,0.4,pow(pos_way/.5,4.));}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(1.25 * scale / lum_band_limit,0.0,1.0),0.33);
    float neg_thresh = 2.;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.35,(neg_way - 1.) / (neg_thresh - 1.)); // 0.9 is nice with 0.8 neg_shift
    if (neg_way < 1.) {neg_hue_shift = mix(0.45,0.,pow(neg_way,4.));}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength * 0.5);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength * 0.5 + 0.5);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));

    

    //return vec4(vec3(edge_grad),1.0);
}

bool is_within(float lower, float higher, float test) {
    if (mod(lower,1.0) < mod(higher, 1.0)) {
        return (mod(test,1.0) > mod(lower,1.0) && (mod(test,1.0) < mod(higher,1.0)));
    }
    if (mod(test,1.0) < mod(lower,1.0)) {
        if (mod(test,1.0) > mod(higher,1.0)) {
            return false;
        }
    }
    return true;
}

float desaturate_region(float hue, float saturation, float deescalate_region, float escalate_region, float gray_region, float gray_start) {
    if (is_within(gray_start - deescalate_region, gray_start, hue)) {
        float delay = mod(hue,1.0) - mod(gray_start - deescalate_region, 1.0);
        if (delay < 0.0) {delay += 1.0;}
        return mix(saturation, -0., delay / deescalate_region);
        return -0.;
    }
    if (is_within(gray_start, gray_start + escalate_region, hue)) {
        float delay = mod(hue,1.0) - mod(gray_start, 1.0);
        if (delay < 0.0) {delay += 1.0;}
        return mix(-0., saturation, delay / escalate_region);
        return -0.;
    }
    return saturation;
}

vec4 sobel(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).r;
    float right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).r;
    float left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).r;

    float upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;
    float upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;

    float hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    float vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float length = length(vec2(hor_grad,vert_grad));

    float edge_grad = mix(0.,0.15,pow(clamp(2.0*(pow(length,1.) / thresh) / lum_band_limit,0.0,1.0),4.));

    

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }

    float lum_grad = mix(0.1,0.6,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.3,0.6,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.1,0.3,scale / 2.);
        }
    }
    //lum_grad += (2. - (2. / 0.55) * (lum_grad - 0.2)) * edge_grad;
    //lum_grad = lum_grad + 0.1 * clamp(10.*pow(edge_grad,0.25),0.0,1.);
    lum_grad = clamp(mix(lum_grad, 1.5 - (0.5 / 0.65) * (lum_grad - 0.1), pow(edge_grad,0.25)),0.0,0.85);
    //lum_grad = mix(lum_grad, 0.9, pow(edge_grad,0.25));

    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }
    //sat_grad = clamp(sat_grad + clamp(1000.*edge_grad,0.0,pow(sat_grad,0.25)*0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10000.*edge_grad,0.0,0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + pow(sat_grad, 0.5) * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);
    sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);

    float neg_range = 0.15;
    float pos_range = 0.15;

    float neg_shift = 0.5; // 0.8 is nice
    float pos_shift = 0.43;

    float pos_way = pow(clamp(1. * scale / lum_band_limit,0.0,1.0),0.5);
    float pos_thresh = 2.;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.33,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = mix(1.6,0.,pos_way);}
    //if (pos_way < 1.) {pos_hue_shift = - mix(0.4,0.,pow((pos_way-.5)*2.,1.));}
    //if (pos_way < .5) {pos_hue_shift = - mix(0.,0.4,pow(pos_way/.5,4.));}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(1.25 * scale / lum_band_limit,0.0,1.0),0.33);
    float neg_thresh = 2.;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.35,(neg_way - 1.) / (neg_thresh - 1.)); // 0.9 is nice with 0.8 neg_shift
    if (neg_way < 1.) {neg_hue_shift = mix(0.45,0.,pow(neg_way,4.));}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;
            }
        else {
            color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;
            }

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;
            }
        else {
            color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;
            }

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength * 0.5);
    }
    else {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;
            }
        else {
            color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;
            }

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength * 0.5 + 0.5);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));

    

    //return vec4(vec3(edge_grad),1.0);
}

vec4 sobel2(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).r;
    float right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).r;
    float left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).r;

    float upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;
    float upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;

    float hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    float vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float length = length(vec2(hor_grad,vert_grad));

    float edge_grad = mix(0.,0.15,pow(clamp(2.0*(pow(length,1.) / thresh) / lum_band_limit,0.0,1.0),4.));

    

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }

    float lum_grad = mix(0.1,0.6,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.3,0.6,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.1,0.3,scale / 2.);
        }
    }
    //lum_grad += (2. - (2. / 0.55) * (lum_grad - 0.2)) * edge_grad;
    //lum_grad = lum_grad + 0.1 * clamp(10.*pow(edge_grad,0.25),0.0,1.);
    lum_grad = clamp(mix(lum_grad, 1.5 - (0.5 / 0.65) * (lum_grad - 0.1), pow(edge_grad,0.25)),0.0,0.85);
    //lum_grad = mix(lum_grad, 0.9, pow(edge_grad,0.25));

    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }
    //sat_grad = clamp(sat_grad + clamp(1000.*edge_grad,0.0,pow(sat_grad,0.25)*0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10000.*edge_grad,0.0,0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + pow(sat_grad, 0.5) * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);
    sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);

    float neg_range = 0.1;
    float pos_range = 0.1;

    float neg_shift = 0.65; // 0.8 is nice
    float pos_shift = 0.43;

    float pos_way = pow(clamp(.5 * scale / lum_band_limit,0.0,1.0),0.5);
    float pos_thresh = 2.;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.33,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = mix(1.6,0.,pos_way);}
    //if (pos_way < 1.) {pos_hue_shift = - mix(0.4,0.,pow((pos_way-.5)*2.,1.));}
    //if (pos_way < .5) {pos_hue_shift = - mix(0.,0.4,pow(pos_way/.5,4.));}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(1.25 * scale / lum_band_limit,0.0,1.0),0.33);
    float neg_thresh = 2.;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.35,(neg_way - 1.) / (neg_thresh - 1.)); // 0.9 is nice with 0.8 neg_shift
    if (neg_way < 1.) {neg_hue_shift = mix(0.35,0.,pow(neg_way,4.));}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.15, 0.15, 0.01, 0.5);
            }
        else {
            color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.2, 0.2, 0.01, 0.65);
            }

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, new_sat, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.15, 0.15, 0.01, 0.5);
            }
        else {
            color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.2, 0.2, 0.01, 0.65);
            }

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, new_sat, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength * 0.5);
    }
    else {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.15, 0.15, 0.01, 0.5);
            }
        else {
            color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.2, 0.2, 0.01, 0.65);
            }

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, new_sat, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength * 0.5 + 0.5);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));

    

    //return vec4(vec3(edge_grad),1.0);
}

vec4 huetest(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).r;
    float right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).r;
    float left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).r;

    float upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;
    float upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;

    float hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    float vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float length = length(vec2(hor_grad,vert_grad));

    float edge_grad = mix(0.,0.15,pow(clamp(2.0*(pow(length,1.) / thresh) / lum_band_limit,0.0,1.0),4.));

    

    float scale = (co) / thresh;

    
    //return vec4(okhsl_to_srgb((vec3(scale,0.5 + 1. * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.3 + clamp(pow(edge_grad,0.25),0.0,0.5)))),1.0);
    //return vec4(okhsl_to_srgb((vec3(scale/100. + 0.05*sin(scale*2.),0.5 + 1. * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.3 + clamp(pow(edge_grad,0.25),0.0,0.5)))),1.0);
    //return vec4(okhsl_to_srgb((vec3(scale/100. + 0.05*sin(scale*2.),0.15 + 1./.85 * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.15 + clamp(pow(edge_grad,0.25),0.0,0.75)))),1.0);
    return vec4(okhsl_to_srgb((vec3(scale/100. + 0.05*sin(scale*2.) + 0.0*clamp(pow(edge_grad,0.25),0.0,0.75),0.25 + clamp(10.*pow(edge_grad,0.25),0.0,0.66),0.5))),1.0);
}

vec4 huetest2(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).r;
    float right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).r;
    float left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).r;

    float upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;
    float upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;

    float hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    float vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float length = length(vec2(hor_grad,vert_grad));

    float edge_grad = mix(0.,0.15,pow(clamp(2.0*(pow(length,1.) / thresh) / lum_band_limit,0.0,1.0),4.));

    

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }

    float lum_grad = mix(0.1,0.6,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.3,0.6,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.1,0.3,scale / 2.);
        }
    }
    //lum_grad += (2. - (2. / 0.55) * (lum_grad - 0.2)) * edge_grad;
    //lum_grad = lum_grad + 0.1 * clamp(10.*pow(edge_grad,0.25),0.0,1.);
    lum_grad = clamp(mix(lum_grad, 1.5 - (0.5 / 0.65) * (lum_grad - 0.1), pow(edge_grad,0.25)),0.0,0.85);
    //lum_grad = mix(lum_grad, 0.9, pow(edge_grad,0.25));

    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }
    //sat_grad = clamp(sat_grad + clamp(1000.*edge_grad,0.0,pow(sat_grad,0.25)*0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10000.*edge_grad,0.0,0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + pow(sat_grad, 0.5) * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);
    sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);

    
    //return vec4(okhsl_to_srgb((vec3(scale,0.01 + 1.75 * clamp(10.*pow(edge_grad,0.25),0.0,0.5),abs(scale)/33. + clamp(pow(edge_grad,0.25),0.0,0.5)))),1.0);
    //return vec4(okhsl_to_srgb((vec3(scale + 100.*clamp(pow(edge_grad,0.25),0.0,0.5),0.01 + 1.75 * clamp(10.*pow(edge_grad,0.25),0.0,0.5),abs(scale)/33.))),1.0);
    //return vec4(okhsl_to_srgb((vec3(scale / 10. + 10.*clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.25 + 1.75 * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.2 * (sin(abs(scale*10.)) + 1.) / 2. + 0.15 + abs(scale)/100.))),1.0);
    //return vec4(okhsl_to_srgb((vec3(mix(scale / 10.,0.05,clamp(5.*clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0)),0.25 + 1.75 * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.2 * (sin(abs(scale*10.)) + 1.) / 2. + 0.15 + abs(scale)/100.))),1.0);

    //vec4 newcolor = vec4(okhsl_to_srgb((vec3(mix(scale / 10.,0.05,clamp(5.*clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0)),0.25 + 1.75 * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.1 * (sin(abs(scale*6.28)) + 1.) / 2. + 0.15 + abs(scale)/100.))),1.0);
    //vec4 newcolor = vec4(okhsl_to_srgb((vec3(scale / 10. + 10.*clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.25 + 0.75*sat_grad,0.25 * (sin(abs(scale*6.28)) + 1.) / 2. + 0.15 + abs(scale)/100.))),1.0);
    vec4 newcolor = vec4(okhsl_to_srgb((vec3(mix(scale / 10.,0.05,clamp(5.*clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0)),0.25 + 0.75*sat_grad,0.25 * (sin(abs(scale*6.28)) + 1.) / 2. + 0.15 + abs(scale)/100.))),1.0);

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 superedge(float co, float thresh, float sat_band_limit, float lum_band_limit){

    float upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).r;
    float right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).r;
    float left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).r;

    float upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;
    float upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r;

    float hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    float vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float length = length(vec2(hor_grad,vert_grad));

    float edge_grad = mix(0.,0.15,pow(clamp(2.0*(pow(length,1.) / thresh) / lum_band_limit,0.0,1.0),4.));


    float avg = (upper + lower + right + left) / 4.;

    float cliff_grad = mix(0.,0.15,pow(clamp(1000.*(abs(co-avg) / thresh) / lum_band_limit,0.0,1.0),4.));

    

    float scale = abs(co) / thresh;

    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }

    float lum_grad = mix(0.2,0.75,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.5,0.65,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.2,0.5,scale / 2.);
        }
    }
    //lum_grad += (2. - (2. / 0.55) * (lum_grad - 0.2)) * edge_grad;
    //lum_grad = lum_grad + 0.1 * clamp(10.*pow(edge_grad,0.25),0.0,1.);
    lum_grad = mix(lum_grad, 0.8, pow(edge_grad,0.25));

    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }
    //sat_grad = clamp(sat_grad + clamp(1000.*edge_grad,0.0,pow(sat_grad,0.25)*0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);
    //sat_grad = clamp(sat_grad + clamp(10000.*edge_grad,0.0,0.5),0.0,1.0);
    sat_grad = clamp(sat_grad + pow(sat_grad, 0.5) * clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);

    float neg_range = 0.15;
    float pos_range = 0.15;

    float neg_shift = 0.5; // 0.8 is nice
    float pos_shift = 0.43;

    float pos_way = pow(clamp(1. * scale / lum_band_limit,0.0,1.0),0.5);
    float pos_thresh = 2.;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.33,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = mix(1.6,0.,pos_way);}
    //if (pos_way < 1.) {pos_hue_shift = - mix(0.4,0.,pow((pos_way-.5)*2.,1.));}
    //if (pos_way < .5) {pos_hue_shift = - mix(0.,0.4,pow(pos_way/.5,4.));}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(1.25 * scale / lum_band_limit,0.0,1.0),0.33);
    float neg_thresh = 2.;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.35,(neg_way - 1.) / (neg_thresh - 1.)); // 0.9 is nice with 0.8 neg_shift
    if (neg_way < 1.) {neg_hue_shift = mix(0.45,0.,pow(neg_way,4.));}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength * 0.5);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength * 0.5 + 0.5);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));

    

    //return vec4(vec3(edge_grad),1.0);
}

vec4 logGradient(float co, float thresh, float v, float sat_band_limit, float lum_band_limit){

    // complete one band cycle by the time the threshold is reached
    float scale = abs(co) / thresh;
    if (abs(co) > thresh) {
        // ex. if v = 2.0, each band cycle represents having 2x the magnitude of the last
        scale = log(abs(co) / thresh) / log(v) + 1.0;
        }
    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    // the band limits determine the number of band cycles until maximum is reached
    float sat_grad = pow(clamp(scale / sat_band_limit,0.,1.),0.5);
    float lum_grad = mix(0.5,0.8,clamp(scale / lum_band_limit,0.0,1.0));

    float neg_range = 0.10;
    float pos_range = 0.16;

    float neg_shift = 0.90;
    float pos_shift = 0.68;

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift;}
        else {color_grad = mix_strength * pos_range + 0.68;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift;}
        else {color_grad = - mix_strength * pos_range / 2.0 + pos_range + pos_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift;}
        else {color_grad = - mix_strength * pos_range / 2.0 + pos_range / 2.0 + pos_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 logGradient2(float co, float thresh, float v, float sat_band_limit, float lum_band_limit){

    // complete one band cycle by the time the threshold is reached
    float scale = abs(co) / thresh;
    if (abs(co) > thresh) {
        // ex. if v = 2.0, each band cycle represents having 2x the magnitude of the last
        scale = log(abs(co) / thresh) / log(v) + 1.0;
        }
    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    // the band limits determine the number of band cycles until maximum is reached
    float sat_grad = pow(clamp(scale / sat_band_limit,0.,1.),0.85) * 0.85 + 0.15;
    float lum_grad = mix(0.3,0.75,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.5,0.65,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 1.) {
            lum_grad = mix(0.3,0.5,scale);
        }
    }
    if (scale < 1.) {
        sat_grad = mix(0.,0.15 + pow(1. / sat_band_limit,0.85) * 0.85, pow(scale,.33));
    }

    float neg_range = 0.12;
    float pos_range = 0.12;

    float neg_shift = 0.65;
    float pos_shift = 0.58;

    float pos_way = pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6);
    float pos_thresh = 2.0;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.45,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = - mix(0.5,0.,pos_way);}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(2. * scale / lum_band_limit,0.0,1.0),1.5);
    float neg_thresh = 8.0;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.2,(neg_way - 1.) / (neg_thresh - 1.));
    if (neg_way < 1.) {neg_hue_shift = mix(0.2,0.,neg_way);}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 logGradient3(float co, float thresh, float v, float sat_band_limit, float lum_band_limit){

    // complete one band cycle by the time the threshold is reached
    float scale = abs(co) / thresh;
    if (abs(co) > thresh) {
        // ex. if v = 2.0, each band cycle represents having 2x the magnitude of the last
        scale = log(abs(co) / thresh) / log(v) + 1.0;
        }
    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    // the band limits determine the number of band cycles until maximum is reached
    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }
    float lum_grad = mix(0.2,0.75,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.5,0.65,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.2,0.5,scale / 2.);
        }
    }
    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }

    float neg_range = 0.15;
    float pos_range = 0.15;

    float neg_shift = 0.55;
    float pos_shift = 0.25;

    float pos_way = pow(clamp(1. * scale / lum_band_limit,0.0,1.0),0.5);
    float pos_thresh = 2.;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.25,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = mix(-0.5,0.,pos_way);}
    //if (pos_way < 1.) {pos_hue_shift = - mix(0.4,0.,pow((pos_way-.5)*2.,1.));}
    //if (pos_way < .5) {pos_hue_shift = - mix(0.,0.4,pow(pos_way/.5,4.));}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(1.25 * scale / lum_band_limit,0.0,1.0),0.33);
    float neg_thresh = 2.;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.25,(neg_way - 1.) / (neg_thresh - 1.));
    if (neg_way < 1.) {neg_hue_shift = mix(0.45,0.,pow(neg_way,4.));}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;}

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength * 0.33);
    }
    else {
        float color_grad = 0.0;
        if (sign(co) < 0.0) {color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;}
        else {color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;}

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, sat_grad, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength * 0.33 + 0.66);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 logSobel(float co, float thresh, float v, float sat_band_limit, float lum_band_limit){

    float upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).r;
    float lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).r;
    float right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).r;
    float left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).r;

    float upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r / thresh;
    upperright = log(abs(upperright) + 1.0);
    float lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r / thresh;
    lowerright = log(abs(lowerright) + 1.0);
    float upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).r / thresh;
    upperleft = log(abs(upperleft) + 1.0);
    float lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).r / thresh;
    lowerleft = log(abs(lowerleft) + 1.0);

    float hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    float vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float length = length(vec2(hor_grad,vert_grad));

    //float edge_grad = mix(0.,0.15,pow(clamp(1000.0*(pow(length/10.,2.)) / lum_band_limit,0.0,1.0),4.));
    float edge_grad = pow(mix(0.,0.15,pow(clamp(10.*length / lum_band_limit,0.0,1.0),4.)) / .15,2.0)*.15;

    

    // complete one band cycle by the time the threshold is reached
    float scale = abs(co) / thresh;
    if (abs(co) > thresh) {
        // ex. if v = 2.0, each band cycle represents having 2x the magnitude of the last
        scale = log(abs(co) / thresh) / log(v) + 1.0;
        }
    float travelled = fract(scale) * 3.;
    float mix_strength = fract(travelled);

    float sat_scale = clamp(scale / sat_band_limit,0.,2.);
    float sat_grad = pow(sat_scale - 1.,.85) * 0.25 + 0.75;
    if (sat_scale < 1.0) {
        sat_grad = pow(sat_scale,1.) * 0.4 + 0.35;
    }

    float lum_grad = mix(0.1,0.6,clamp(scale / lum_band_limit,0.0,1.0));
    if (sign(co) > 0.) {
        lum_grad = mix(0.3,0.6,clamp(scale / lum_band_limit,0.0,1.0));
        if (scale < 2.) {
            lum_grad = mix(0.1,0.3,scale / 2.);
        }
    }
    lum_grad = clamp(mix(lum_grad, 1.5 - (0.5 / 0.65) * (lum_grad - 0.1), pow(edge_grad,0.25)),0.0,0.85);

    if (scale < 1.) {
        sat_grad = mix(0.,0.35 + pow(1. / sat_band_limit,0.85) * 0.4, pow(scale,.5));
    }
    sat_grad = clamp(sat_grad + clamp(10.*pow(edge_grad,0.25),0.0,0.5),0.0,1.0);

    float neg_range = 0.1;
    float pos_range = 0.1;

    float neg_shift = 0.65; // 0.8 is nice
    float pos_shift = 0.43;

    float pos_way = pow(clamp(.5 * scale / lum_band_limit,0.0,1.0),0.5);
    float pos_thresh = 2.;
    pos_way = pos_way * pos_thresh;
    float pos_hue_shift = - mix(0.,.33,(pos_way - 1.) / (pos_thresh - 1.));
    if (pos_way < 1.) {pos_hue_shift = mix(1.6,0.,pos_way);}
    //if (pos_way < 1.) {pos_hue_shift = - mix(0.4,0.,pow((pos_way-.5)*2.,1.));}
    //if (pos_way < .5) {pos_hue_shift = - mix(0.,0.4,pow(pos_way/.5,4.));}

    //float pos_hue_shift = - mix(0.,0.65,pow(clamp(2. * scale / lum_band_limit,0.0,1.0),0.6));

    float neg_way = pow(clamp(1.25 * scale / lum_band_limit,0.0,1.0),0.33);
    float neg_thresh = 2.;
    neg_way = neg_way * neg_thresh;
    float neg_hue_shift = mix(0.,0.35,(neg_way - 1.) / (neg_thresh - 1.)); // 0.9 is nice with 0.8 neg_shift
    if (neg_way < 1.) {neg_hue_shift = mix(0.35,0.,pow(neg_way,4.));}

    vec4 graycolor = vec4(0.0);
    if (sign(co) < 0.0) {graycolor = vec4(okhsl_to_srgb(vec3(neg_range / 2.0 + neg_shift, 0.5, lum_grad)), 1.0);}
    else {graycolor = vec4(okhsl_to_srgb(vec3(pos_range / 2.0 + pos_shift, 0.5, lum_grad)), 1.0);}

    vec4 newcolor = vec4(0.0);
    if (travelled < 1.0) {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = mix_strength * neg_range + neg_shift + neg_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.15, 0.15, 0.01, 0.5);
            }
        else {
            color_grad = - mix_strength * pos_range + pos_shift + pos_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.2, 0.2, 0.01, 0.65);
            }

        newcolor = vec4(okhsl_to_srgb(vec3(color_grad, new_sat, lum_grad)), 1.0);
    }
    else if (travelled < 2.0) {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = - mix_strength * neg_range / 2.0 + neg_range + neg_shift + neg_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.15, 0.15, 0.01, 0.5);
            }
        else {
            color_grad = mix_strength * pos_range / 2.0 - pos_range + pos_shift + pos_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.2, 0.2, 0.01, 0.65);
            }

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, new_sat, lum_grad)), 1.0);
        newcolor = mix(vividcolor, graycolor, mix_strength * 0.5);
    }
    else {
        float color_grad = 0.0;
        float new_sat = 0.0;
        if (sign(co) < 0.0) {
            color_grad = - mix_strength * neg_range / 2.0 + neg_range / 2.0 + neg_shift + neg_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.15, 0.15, 0.01, 0.5);
            }
        else {
            color_grad = mix_strength * pos_range / 2.0 - pos_range / 2.0 + pos_shift + pos_hue_shift;
            new_sat = desaturate_region(color_grad, sat_grad, 0.2, 0.2, 0.01, 0.65);
            }

        vec4 vividcolor = vec4(okhsl_to_srgb(vec3(color_grad, new_sat, lum_grad)), 1.0);
        newcolor = mix(graycolor, vividcolor, mix_strength * 0.5 + 0.5);
    }

    return mix(vec4(0.0), newcolor, pow(sat_grad,2.0));
}

vec4 colorMap(vec2 co){
    //return vec4(0.0);
    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = clamp(length(co),0.,2.);
    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(mag, 1.0), mix(0.75, mag * 0.5, 0.5))), 1.0);

    return mix(vec4(0.0), newcolor, min(mag, 1.0));
}

vec4 colorMap2(vec2 co){
    vec2 upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).rg;
    vec2 right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).rg;
    vec2 left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).rg;

    vec2 upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).rg;
    vec2 upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).rg;

    vec2 hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    vec2 vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float length1 = length(vec4(hor_grad,vert_grad));

    float edge_grad = mix(0.,0.75,pow(clamp(pow(length1,1.),0.0,1.0),.5));

    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = clamp(length(co),0.,2.);
    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(mag, 1.0), mix(0.75 - edge_grad, mag/2., 0.5))), 1.0);

    return mix(vec4(0.0), newcolor, min(mag + edge_grad, 1.0));

    //return vec4(0.0);
}

vec4 colorMap3(vec2 co){
    //return vec4(0.0);
    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = clamp(length(co),0.,2.);

    float repetitions = 25.;
    float strength = 6.;

    float hor_min = min(mod(co.x, 1./repetitions), mod(-co.x, 1./repetitions));
    float ver_min = min(mod(co.y, 1./repetitions), mod(-co.y, 1./repetitions));

    float hor = pow(hor_min * repetitions, strength);
    float ver = pow(ver_min * repetitions, strength);

    float scale = - (hor + ver) / 0.25;

    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(mag, 1.0), mix(0.75, mag * 0.5, 0.5) - scale)), 1.0);

    return mix(vec4(0.0), newcolor, min(mag, 1.0));
}

vec4 colorMap4(vec2 co){
    //return vec4(0.0);
    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = clamp(length(co),0.,2.);

    float repetitions = 25.;
    float strength = 6.;

    float hor_min = min(mod(angle, 1./repetitions), mod(-angle, 1./repetitions));
    float ver_min = min(mod(length(co), 1./repetitions), mod(-length(co), 1./repetitions));

    float hor = pow(hor_min * repetitions, strength);
    float ver = pow(ver_min * repetitions, strength);

    float scale = - (hor + ver) / .25;

    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(mag, 1.0), mix(0.75, mag * 0.5, 0.5) - scale)), 1.0);

    return mix(vec4(0.0), newcolor, min(mag, 1.0));
}

vec4 colorMap5(vec2 co){
    //return vec4(0.0);
    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = clamp(length(co),0.,2.);

    float repetitions = 16.;
    float strength = 6.;

    float hor_min = max(mod(angle, 1./repetitions), mod(-angle, 1./repetitions));
    float ver_min = max(mod(length(co), 1./repetitions), mod(-length(co), 1./repetitions));

    float hor = pow(hor_min * repetitions, strength);
    float ver = pow(ver_min * repetitions, strength);

    float scale = - (hor + ver) / 32.; // 1. looks insane, might be worth looking into to fix it up

    float repetitions2 = repetitions * 4.;
    float strength2 = 6.;

    float hor_min2 = max(mod(angle, 1./repetitions2), mod(-angle, 1./repetitions2));
    float ver_min2 = max(mod(length(co), 1./repetitions2), mod(-length(co), 1./repetitions2));

    float hor2 = pow(hor_min2 * repetitions2, strength2);
    float ver2 = pow(ver_min2 * repetitions2, strength2);

    float scale2 = - (hor2 + ver2) / 32.;

    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(mag, 1.0), clamp(mix(0.75, mag * 0.5, 0.5) - scale - scale2,0.0,1.0))), 1.0);

    return mix(vec4(0.0), newcolor, min(mag, 1.0));
}

vec4 colorMap6(vec2 co){
    //return vec4(0.0);
    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = pow(clamp(length(co),0.,2.),0.37) * 2./pow(2.,0.37);

    float repetitions = 16.;
    float strength = 6.;

    float hor_min = max(mod(angle, 1./repetitions), mod(-angle, 1./repetitions));
    float ver_min = max(mod(length(co), 1./repetitions), mod(-length(co), 1./repetitions));

    float hor = pow(hor_min * repetitions, strength);
    float ver = pow(ver_min * repetitions, strength);

    float scale = - (hor + ver) / 8.;

    float repetitions2 = repetitions * 4.;
    float strength2 = 6.;

    float hor_min2 = max(mod(angle, 1./repetitions2), mod(-angle, 1./repetitions2));
    float ver_min2 = max(mod(length(co), 1./repetitions2), mod(-length(co), 1./repetitions2));

    float hor2 = pow(hor_min2 * repetitions2, strength2);
    float ver2 = pow(ver_min2 * repetitions2, strength2);

    float scale2 = - (hor2 + ver2) / 32.;

    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(mag, 1.0), clamp(mag * 0.25 - scale - scale2,0.0,0.75))), 1.0);

    return mix(vec4(0.0), newcolor, min(mag, 1.0));
}

vec4 colorMap7(vec2 co){
    vec2 upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).rg;
    vec2 right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).rg;
    vec2 left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).rg;

    vec2 upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).rg;
    vec2 upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).rg;

    vec2 hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    vec2 vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float sobel = length(vec4(hor_grad,vert_grad));

    float edge_grad = mix(0.,.25,pow(clamp(pow(sobel,1.0),0.0,1.0),.5));

    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = pow(clamp(length(co),0.,2.),1.) * 2./pow(2.,1.);

    float repetitions = 16.;
    float strength = 6.;

    float hor_min = max(mod(angle, 1./repetitions), mod(-angle, 1./repetitions));
    float ver_min = max(mod(length(co), 1./repetitions), mod(-length(co), 1./repetitions));

    float hor = pow(hor_min * repetitions, strength);
    float ver = pow(ver_min * repetitions, strength);

    float scale = - (hor + ver) / 8.;

    float repetitions2 = repetitions * 4.;
    float strength2 = 6.;

    float hor_min2 = max(mod(angle, 1./repetitions2), mod(-angle, 1./repetitions2));
    float ver_min2 = max(mod(length(co), 1./repetitions2), mod(-length(co), 1./repetitions2));

    float hor2 = pow(hor_min2 * repetitions2, strength2);
    float ver2 = pow(ver_min2 * repetitions2, strength2);

    float scale2 = - (hor2 + ver2) / 32.;

    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(pow(mag,.5), 1.0), clamp(mag * 0.2 - scale - scale2 + edge_grad,0.05,0.75))), 1.0);

    return mix(vec4(0.0), newcolor, min(pow(mag,0.5), 1.0));
}

vec4 colorMap8(vec2 co){
    vec2 upper = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lower = texture(u_image, vec2(v_texCoord.x, mod(v_texCoord.y - epsilon.y, 1.))).rg;
    vec2 right = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), v_texCoord.y)).rg;
    vec2 left  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), v_texCoord.y)).rg;

    vec2 upperright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lowerright = texture(u_image, vec2(mod(v_texCoord.x + epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).rg;
    vec2 upperleft = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y + epsilon.y, 1.))).rg;
    vec2 lowerleft  = texture(u_image, vec2(mod(v_texCoord.x - epsilon.x, 1.), mod(v_texCoord.y - epsilon.y, 1.))).rg;

    vec2 hor_grad = abs(upperleft + 2. * left + lowerleft - (upperright + 2. * right + lowerright));
    vec2 vert_grad = abs(upperleft + 2. * upper + upperright - (lowerleft + 2. * lower + lowerright));

    float sobel = length(vec4(hor_grad,vert_grad));

    float laplacian = pow(clamp(length(8. * co - (upper + lower + right + left + upperright + lowerright + upperleft + lowerleft)), 0.0,1.0),2.0);

    float edge_grad = mix(0.,.25,pow(clamp(pow(sobel,1.0),0.0,1.0),.5));

    float angle = atan(co.y, co.x) / (2. * M_PI);
    float mag = pow(clamp(length(co),0.,2.),1.) * 2./pow(2.,1.);

    float repetitions = 16.;
    float strength = 6.;

    float hor_min = max(mod(angle, 1./repetitions), mod(-angle, 1./repetitions));
    float ver_min = max(mod(length(co), 1./repetitions), mod(-length(co), 1./repetitions));

    float hor = pow(hor_min * repetitions, strength);
    float ver = pow(ver_min * repetitions, strength);

    float scale = - (hor + ver) / 8.;

    float repetitions2 = repetitions * 4.;
    float strength2 = 6.;

    float hor_min2 = max(mod(angle, 1./repetitions2), mod(-angle, 1./repetitions2));
    float ver_min2 = max(mod(length(co), 1./repetitions2), mod(-length(co), 1./repetitions2));

    float hor2 = pow(hor_min2 * repetitions2, strength2);
    float ver2 = pow(ver_min2 * repetitions2, strength2);

    float scale2 = - (hor2 + ver2) / 32.;

    vec4 newcolor = vec4(okhsl_to_srgb(vec3(angle, min(pow(mag,0.5), 1.0), (1.0-(.66*laplacian)) * clamp(mag * 0.2 - scale - scale2 + edge_grad,0.05,0.75))), 1.0);

    /*
    if (v_texCoord.x > 0.5) {
        newcolor = vec4(okhsl_to_srgb(vec3(angle, min(pow(mag,0.5), 1.0), (1.0-(.66*laplacian)) * clamp(mag * 0.2 - scale - scale2 + edge_grad,0.05,0.75))), 1.0);}
    else {
        newcolor = vec4(okhsl_to_srgb(vec3(angle, min(pow(mag,0.5), 1.0), clamp(mag * 0.2 - scale - scale2 + edge_grad,0.05,0.75))), 1.0);}
    */

    return mix(vec4(0.0), newcolor, min(pow(mag,0.5), 1.0));
}

float circleMix(float mix1, float mix2, float a) {
	float res = mix(mix1, mix2, a);
	if (distance(mix1, mix2) > 0.5) {(mix1 == min(mix1, mix2)) ? res =  mix(mix1 + 1.0, mix2, a) : res =  mix(mix1, mix2 + 1.0, a);}
	return res;
}
float ditherHue( float h, float r1, float r2, float r3, float antiRad, float ts) {
	float rightBound = h - antiRad * r2;
    if (rightBound < -0.5) rightBound = rightBound + 1.0;
    float leftBound = h + antiRad * r2;
    if (leftBound > 0.5) leftBound = leftBound - 1.0;
	if ((h > h - antiRad) && (h < h + antiRad))
        if (((h - (h - antiRad)) / (2.0f * antiRad)) < r1)
            h = rightBound;
        else h = leftBound;
    else if ((h - 1.0 > h - antiRad) && (h - 1.0 < h + antiRad))
        if (((h - 1.0 - (h - antiRad)) / (2.0 * antiRad)) < r1)
            h = rightBound;
        else h = leftBound;
    else if ((1.0 + h > h - antiRad) && (1.0 + h < h + antiRad))
        if (((1.0 + h - (h - antiRad)) / (2.0 * antiRad)) < r1)
            h = rightBound;
        else h = leftBound;
	if (h < 0.0) h = h + 1.0;
	if (ts < 0.05) h = circleMix(r3, h, 25.0*(ts - 0.01)); // h is based on r, so you really should put in a new r!!!
	if (ts < 0.01) h = r3;
	return h;
}
float truedither( float v, float r, float antiRad, float lim) {
    float lowerBound = max(0.0, v - antiRad);
    if (v - antiRad < lim) lowerBound = mix(max(0.0, v - antiRad), lim, antiRad);
    float upperBound = min(lowerBound + 2.0 * antiRad, 1.0 - lim);
    if (v + antiRad > 1.0 - lim) {
        upperBound = mix(min(1.0, v + antiRad), 1.0 - lim, antiRad);
        lowerBound = max(lowerBound, upperBound - 2.0 * antiRad);
    }
    return mix(lowerBound, upperBound, r);
}
vec3 ditherOut(vec3 rgbcolor, vec4 rands) {
    vec3 okhslcolor = srgb_to_okhsl(rgbcolor);
    //return okhsl_to_srgb(vec3(ditherHue(okhslcolor.x, rands[0], rands[1], rands[2], 1.0, .5),
    //   truedither(okhslcolor.y, rands[1], 0.0, 0.0),
    //   truedither(okhslcolor.z, rand(vec2(rands[0]*100.+rands[1]*10.,rands[3]*100.-rands[2]*5.)), 1.0, 0.75)));
    return okhsl_to_srgb(vec3(okhslcolor.x,
       truedither(okhslcolor.y, rands[1], 0.0, 0.0),
       truedither(okhslcolor.z, rand(vec2(rands[0]*100.+rands[1]*10.,rands[3]*100.-rands[2]*5.)), 1.0, 0.5)));
}

void main() {
    vec4 color = texture(u_image, v_texCoord);
    //color = texture(u_image, v_texCoord + 0.01 * vec2(rand(v_texCoord),rand(v_texCoord + 0.1)) - 0.005);
    //color = texture(u_image, v_texCoord + 0.01 * vec2(rand(v_texCoord * time),rand(v_texCoord * time*1.9 + 0.1)) - 0.005);

    // for when you wanna use this shader to debug other things

    //color = lineGradient(color.r, 32., 4., 2.); // pressure
    // color = lineGradient2(color.r, 1. / pow(2.,6.), pow(2.,3.), pow(2.,4.)); // pressure
    //if (mode == 1) {color = lineGradient(color.r, 32., 4., 2.);} // pressure
    //if (mode == 1) {color = lineGradient2(color.r, 1. / pow(2.,6.), pow(2.,3.), pow(2.,5.));} // pressure
    //if (mode == 1) {color = lineGradient2(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 1) {color = lineGradient3(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 1) {color = lineGradient4(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 1) {color = lineGradient4(color.r, 1. / pow(2.,10.), pow(2.,8.), pow(2.,10.));} // pressure
    //if (mode == 1) {color = edge(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 1) {color = sobel(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 1) {color = huetest(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 1) {color = huetest2(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 1) {color = mix(huetest2(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.)),sobel2(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.)),clamp(v_texCoord.y*1.5 - 0.25, 0.0,1.0));} // pressure
    /*if (mode == 1) {
        if (v_texCoord.y < 0.5) {
            color = huetest2(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));
        }
        else {
            color = sobel2(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));
        }
    }
    */
    if (mode == 1) {color = sobel2(color.r, 1. / pow(2.,7.), pow(2.,4.), pow(2.,6.));} // pressure

    //if (mode == 2) {color = logGradient(color.r, 1. / pow(2.,12.), pow(2.,0.5), pow(2.,3.), pow(2.,4.));} // divergence
    //if (mode == 2) {color = logGradient(color.r, 1. / pow(2.,10.), pow(2.,0.5), pow(2.,3.), pow(2.,4.));} // divergence
    //if (mode == 2) {color = logGradient(color.r, 1. / pow(2.,10.), pow(2.,.5), pow(2.,3.), pow(2.,5.));} // divergence
    //if (mode == 2) {color = logGradient2(color.r, 1. / pow(2.,11.), pow(2.,.5), pow(2.,3.), pow(2.,4.));} // divergence
    //if (mode == 2) {color = logGradient3(color.r, 1. / pow(2.,12.), pow(2.,.25), pow(2.,3.), pow(2.,5.));} // divergence
    //if (mode == 2) {color = lineGradient2(color.r, 1. / pow(2.,12.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 2) {color = lineGradient3(color.r, 1. / pow(2.,12.), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 2) {color = sobel2(color.r, 1. / pow(2.,12.), pow(2.,4.), pow(2.,6.));} // pressure
    if (mode == 2) {color = logSobel(color.r, 1. / pow(2.,12.), pow(2.,.5), pow(2.,4.), pow(2.,6.));} // pressure
    //if (mode == 2) {color = logGradient(color.r, 1. / pow(2.,12.), pow(2.,1.), pow(2.,2.), pow(2.,3.));} // divergence
    if (mode == 3) {color = colorMap7(color.rg);} // velocity
    //if (mode == 3) {color = colorMap2(color.rg);} // velocity
    //color = lineGradient(color.r, pow(2.,10.), pow(2.,8.), pow(2.,6.)); // divergence
    //color = logGradient(color.r, 1. / pow(2.,12.), pow(2.,1.), pow(2.,2.), pow(2.,3.)); // divergence
    //color = colorMap(color.rg); // velocity

    vec4 noise = vec4(rand(vec2(rand(v_texCoord * 100.) * 100., time / 1000.)) / 255.,
        rand(vec2(rand((v_texCoord + 0.1) * 100.) * 2., time)) / 255.,
        rand(vec2(rand((v_texCoord + 0.2) * 100.) * 7., time)) / 255.,
        rand(vec2(rand((v_texCoord + 0.3) * 100.) * 55., time)) / 255.);
    //color = vec4(okhsl_to_srgb(color.a * vec3(rand(vec2(v_texCoord.x * 10.0 + v_texCoord.y * 67., mod(time, 1.0) * v_texCoord.x * v_texCoord.y)), 1.0, 0.5)), color.a);
    //float hue = rand(vec2(v_texCoord.x * 4.0 + v_texCoord.y * 4., mod(time, 1.0) * 4. * v_texCoord.x * v_texCoord.y)) * 2.0 * 3.1415926535;
    //color = color.a * vec4(oklab_to_linear_srgb(vec3(0.5, color.g * sin(hue), color.g * cos(hue))) + .6, 1.0);

    //color = vec4(pow(color.a, 0.5)*color.rgb, color.a); could be useful for light mode
    outColor = color - 1.0 * noise;
    //outColor = (color.a * 0.5 + 0.5)*vec4(ditherOut(color.rgb, noise.rgba * 255.),1.0);
    //outColor = vec4(ditherOut(color.rgb, noise.rgba * 255.),1.0);
}
</script>
<script type = "text" id = "output">
uniform sampler2D u_image;
in vec2 v_texCoord;
out vec4 outColor;

void main() {
    outColor = texture(u_image, v_texCoord);
}
</script>
<div align="center" id='checkboxes' style="height:42px">
<br>
<input type="checkbox" id="sprite" name="sprite" value="0" checked="checked">
<label for="0">Sprite</label>
<input type="checkbox" id="glitter" name="glitter" value="1">
<label for="1">Glitter</label>
<input type="checkbox" id="lock" name="lock" value="2">
<label for="2">Lock Color Direction</label>
</div>
<div align="center" id="slider-fill">
<svg width="36px" height="36px" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg" style="position:relative; top:-16px; left:5px"><path fill="gray" d="M321.375 15.313L262.72 73.906l25.78 6.906-15.563 58.063c-5.44-.756-10.87-1.14-16.25-1.125-.887.003-1.77.04-2.656.063l21.97 45.75 42.25-28.407c-6.263-3.87-12.944-7.205-20.03-9.875l15.467-57.718 28.657 7.657-20.97-79.907zM133.25 40.063l-.094 82.906 23.125-13.345 30.064 52.063c-5.034 3.824-9.75 8.072-14.125 12.687l50.06 16.438 9.064-50.157c-7.797 1.777-15.372 4.336-22.594 7.625l-29.875-51.718 25.688-14.812-71.313-41.688zm255.28 90.593l13.345 23.094-52.063 30.063c-3.8-5.002-8.01-9.707-12.593-14.063l-16.126 48.156 49.28 8.938c-1.744-7.094-4.148-13.99-7.155-20.594l51.717-29.875 14.813 25.656 41.688-71.31-82.907-.064zm-290.78 38.5l-79.906 20.97 58.562 58.655L83.312 223l58.063 15.563c-.935 6.767-1.25 13.498-1 20.156l47.53-22.814-29.843-43.25c-4.022 6.432-7.466 13.31-10.218 20.625l-57.78-15.468 7.686-28.656zm275.875 81.28L328.5 272.813l28.313 42.125c3.15-5.2 5.937-10.673 8.28-16.437l57.938 15.53-6.905 25.783 80.063-21.532-58.72-58.092-7.687 28.656-57.592-15.438c1.27-7.706 1.707-15.387 1.437-22.97zm-230.28 30.283c1.5 6.44 3.516 12.72 6.06 18.78l-52.093 30.094L83.97 306.5l-41.376 71.813 82.594-.438-14.813-25.656 51.78-29.908c4.655 6.52 9.98 12.557 15.907 18.032l17.282-49.53-52-10.095zM294 316.75l-9.22 51.03c5.91-1.454 11.673-3.347 17.25-5.686l30.095 52.094L309 427.53l71.844 41.408-.438-82.625-25.687 14.843-29.876-51.75c6.437-4.588 12.43-9.847 17.844-15.687L294 316.75zM240.25 324l-44.125 30.03c5.32 3.262 10.955 6.127 16.875 8.533L197.47 420.5l-25.782-6.906 21.53 80.062 58.095-58.72-28.625-7.686 15.437-57.625c8.295 1.367 16.576 1.816 24.72 1.406L240.25 324z"/></svg>
</div>
<div align="center" id="slider-fill2">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="36" height="36" viewBox="0 0 1207.000000 1280.000000"
 preserveAspectRatio="xMidYMid meet"
 style="position:relative; top:-14px; left:7px">
<metadata>
Created by potrace 1.15, written by Peter Selinger 2001-2017
</metadata>
<g transform="translate(0.000000,1280.000000) scale(0.100000,-0.100000)"
fill="#000000" stroke="none">
<path fill = 'gray' d="M8175 12786 c-280 -68 -666 -492 -845 -926 -111 -270 -214 -833 -300
-1647 -22 -206 -43 -303 -84 -397 -103 -232 -335 -420 -535 -433 -91 -6 -143
6 -207 50 -73 49 -107 118 -112 226 -5 108 13 165 109 349 114 217 169 409
169 585 0 120 -21 213 -69 312 -64 131 -125 187 -309 282 -103 53 -149 56
-237 14 -96 -45 -129 -93 -171 -248 -27 -97 -27 -102 -28 -438 -1 -291 -3
-345 -17 -376 -34 -74 -117 -147 -209 -183 -71 -29 -201 -45 -283 -35 -89 10
-127 23 -195 66 -151 96 -272 286 -497 783 -164 362 -198 423 -285 511 -218
221 -487 208 -735 -37 -39 -38 -88 -96 -109 -128 -44 -66 -93 -210 -103 -297
-12 -116 29 -260 137 -484 139 -286 211 -355 498 -475 247 -103 301 -139 343
-233 21 -45 24 -67 24 -172 0 -116 -1 -122 -33 -183 -39 -75 -105 -145 -158
-167 -20 -8 -80 -20 -133 -26 -53 -5 -116 -15 -140 -21 -70 -18 -222 -142
-257 -210 -9 -17 -27 -70 -40 -117 -28 -101 -32 -259 -10 -381 66 -356 65
-333 6 -397 -120 -128 -249 -175 -346 -125 -21 11 -84 59 -139 106 -220 190
-430 307 -680 376 -215 60 -302 97 -390 164 -22 16 -170 159 -330 316 -280
275 -411 396 -455 420 -30 16 -83 -4 -115 -42 -92 -109 -146 -384 -96 -493 40
-89 114 -126 401 -200 284 -74 382 -112 505 -200 118 -83 196 -185 330 -430
48 -88 107 -188 132 -222 75 -107 234 -236 454 -369 154 -93 209 -161 209
-263 0 -26 -8 -42 -35 -67 -80 -75 -248 -105 -482 -86 -382 32 -493 86 -1103
535 -526 387 -572 414 -754 437 -156 19 -304 -27 -373 -118 -36 -48 -80 -177
-89 -262 -10 -99 40 -272 113 -390 50 -79 370 -394 468 -459 150 -100 387
-198 575 -238 62 -13 128 -18 245 -18 170 1 203 6 398 61 306 86 660 67 990
-53 263 -96 354 -236 266 -411 -39 -78 -82 -115 -211 -179 -141 -70 -264 -114
-469 -168 -96 -25 -204 -57 -241 -71 -87 -33 -168 -92 -207 -151 -41 -61 -75
-173 -75 -243 0 -141 141 -250 323 -250 103 0 139 14 222 88 109 97 424 358
492 408 185 137 407 77 407 -110 0 -71 -26 -137 -165 -411 -232 -457 -352
-642 -609 -940 -434 -502 -517 -619 -587 -825 -67 -201 -85 -381 -54 -532 22
-104 53 -160 147 -266 172 -192 305 -267 549 -308 203 -34 332 7 494 155 134
122 205 234 256 406 22 72 24 97 23 260 -1 156 -6 210 -37 400 -50 304 -60
408 -55 549 4 128 14 161 60 202 86 79 196 70 314 -24 135 -108 213 -290 214
-499 0 -160 -19 -232 -153 -569 -137 -346 -189 -543 -191 -734 -1 -132 8 -157
92 -231 89 -80 211 -115 366 -107 98 5 170 39 217 102 36 49 85 199 100 304
27 187 -23 688 -107 1079 -30 138 -30 194 -3 249 75 156 290 196 512 96 89
-41 122 -73 232 -234 174 -254 187 -264 319 -256 161 10 304 125 356 285 32
98 28 137 -25 258 -51 117 -70 196 -55 225 32 59 122 92 183 66 27 -11 52 -48
161 -237 679 -1173 830 -1534 1160 -2771 106 -397 136 -480 215 -596 101 -149
266 -282 402 -323 108 -33 176 -12 265 82 68 74 106 144 156 290 37 112 42
136 46 245 9 258 -66 417 -415 879 -413 547 -588 783 -673 905 -443 643 -782
1322 -806 1615 l-6 70 33 19 c43 25 179 34 258 16 80 -17 187 -72 264 -136
128 -106 241 -269 434 -629 162 -300 288 -433 466 -487 116 -35 194 -10 319
99 146 128 226 239 268 371 36 113 37 138 9 197 -44 94 -292 327 -418 393 -66
35 -216 87 -394 137 -176 49 -216 71 -322 179 -140 142 -195 252 -202 406 -5
82 -4 87 27 133 88 131 175 129 539 -10 502 -192 1027 -515 1531 -943 277
-235 314 -266 410 -337 177 -130 295 -188 487 -239 127 -34 232 -37 288 -8 53
27 77 65 116 181 58 174 29 274 -123 425 -79 79 -100 94 -210 147 -68 33 -247
103 -398 155 -548 191 -651 233 -1035 420 -430 209 -630 345 -761 519 -66 87
-127 217 -132 282 -4 52 -3 54 44 106 81 87 159 107 274 73 30 -9 120 -49 200
-89 349 -174 651 -258 834 -231 87 13 139 81 190 247 54 176 38 213 -159 376
-295 245 -358 353 -288 492 59 119 201 236 350 288 70 25 91 28 213 28 113 0
147 -4 210 -23 159 -50 342 -167 666 -427 256 -207 280 -223 343 -241 155 -46
352 61 438 236 43 89 93 263 93 325 0 105 -78 203 -255 321 -207 137 -451 207
-1045 299 -278 43 -348 58 -455 96 -167 60 -297 200 -340 366 -21 80 -20 254
1 299 32 68 180 172 354 250 231 102 401 147 565 148 214 1 359 -53 718 -266
254 -151 435 -231 642 -283 322 -82 579 -47 712 98 70 76 119 236 110 362 -14
209 -109 352 -457 688 -182 177 -291 261 -429 331 -361 184 -627 218 -987 126
-138 -35 -223 -75 -325 -152 -95 -72 -169 -157 -292 -338 -150 -220 -253 -310
-457 -396 -138 -58 -228 -77 -344 -72 -82 3 -111 9 -157 30 -161 74 -212 221
-174 506 22 162 17 270 -13 333 -12 25 -48 71 -79 102 -120 120 -211 137 -478
92 -179 -31 -254 -30 -333 5 -97 43 -178 155 -201 277 -23 116 55 422 204 804
145 372 322 654 569 907 129 133 243 230 437 375 168 125 235 189 244 234 4
15 13 43 21 61 19 44 18 84 -6 167 -35 124 -96 231 -180 315 -41 42 -98 88
-126 102 -102 55 -221 70 -329 44z"/>
</g>
</svg>
</div>
<div align="center" id="slider-fill3"><svg xmlns="http://www.w3.org/2000/svg" width="40" height="36" viewBox="0 0 24 24"
        style="position:relative; top:-15px; left: 5px">
        <path fill='gray'
            d="M12 0l-11 6v12.131l11 5.869 11-5.869v-12.066l-11-6.065zm9 11.623l-3 1.569v-3.26l3-1.601v3.292zm-13-.654l3 1.625v3.186l-3-1.614v-3.197zm.9-1.799l2.986-1.603 3.132 1.688-3.014 1.608-3.104-1.693zm4.1 3.43l3-1.6v3.238l-3 1.569v-3.207zm4.138-4.475l-3.139-1.691 2.801-1.503 3.11 1.715-2.772 1.479zm-2.424-4.345l-2.825 1.517-2.728-1.47 2.834-1.546 2.719 1.499zm-7.649 1.19l2.711 1.46-2.973 1.596-2.67-1.456 2.932-1.6zm-1.065 4.908v3.204l-3-1.636v-3.216l3 1.648zm-3 3.843l3 1.636v3.185l-3-1.611v-3.21zm5 5.888v-3.169l3 1.614v3.146l-3-1.591zm5-1.545l3-1.569v3.104l-3 1.601v-3.136zm5 .468v-3.083l3-1.569v3.051l-3 1.601z" /></svg></div>
<div align="center" id='radiobtn'>
<br>
<input type="radio" id="radio_main" name="mode" value="0" checked="checked">
<label for="0">Main</label>
<input type="radio" id="radio_pressure" name="mode" value="1">
<label for="1">Pressure</label>
<input type="radio" id="radio_divergence" name="mode" value="2">
<label for="2">Divergence</label>
<input type="radio" id="radio_velocity" name="mode" value="3">
<label for="3">Velocity</label>
</div>
<div id="space" style="display: block; height: 100vh; user-select: none"></div>
<script type="text/javascript">
"use strict";

// based on: https://jamie-wong.com/2016/08/05/webgl-fluid-simulation/#divergent-fields
// this also helped: https://gpfault.net/posts/webgl2-particles.txt.html
// this one too https://blog.mapbox.com/how-i-built-a-wind-map-with-webgl-b63022b5537f 
// this can help with gradients: https://iquilezles.org/articles/palettes/ 
// originally posted: 2022-11-22T23:06:06+01:00, but has been updated many times

// Get A WebGL context
var toggle = true;
const btn = document.getElementById('btn');
//const radiobtn = document.getElementById('radiobtn');
//const checkboxes = document.getElementById('checkboxes');
var mode = parseInt(document.querySelector('input[name="mode"]:checked').value);
var spriteOnOff = document.getElementById("sprite").checked;
var canvas = document.querySelector("canvas");
const gl = canvas.getContext("webgl2", {premultipliedAlpha: true});
gl.getExtension('EXT_color_buffer_float'); // allows for float textures (instead of 256 colors like regular)
//gl.getExtension('OES_texture_float_linear'); // does automatic bilinear interpolation (or at least I assume it's bilinear)
if (`drawingBufferColorSpace` in gl) {
    gl.drawingBufferColorSpace = 'display-p3';
    console.log(gl.drawingBufferColorSpace);
}
var scaleFactor = 4.;

// size
var width = window.innerWidth / scaleFactor;
var height = window.innerHeight / scaleFactor;

document.onscroll = function() {
    var darkval = parseInt(Math.max(0,Math.min(24, document.getElementById('space').getBoundingClientRect().y / 20)));
    var darkstyle = document.getElementsByClassName("dark");
    //console.log(darkstyle);
    if (localStorage.theme == "dark") {
        document.body.style.backgroundColor = "rgb(" + darkval + "," + darkval + "," + darkval + ")";
        }
}

document.onclick = function() {
    var darkval = parseInt(Math.max(0,Math.min(24, document.getElementById('space').getBoundingClientRect().y / 20)));
    if (localStorage.theme == "dark") {
        document.body.style.backgroundColor = "rgb(" + darkval + "," + darkval + "," + darkval + ")";
        }
    else {
        document.body.style.backgroundColor = "rgb(255,255,255)";
    }
}

// important for interacting with the canvas
var mouseDown = false,
    mouseX = 0,
    mouseY = 0,
    deltaX = 0,
    deltaY = 0;
var initialDirection = 0.0;
var count = 1;
var totalDX = 0;
var totalDY = 0;

window.addEventListener('pointerdown', function (event) {
    initialDirection = 0.0;
    mouseX = event.clientX / canvas.width;
    mouseY = 1.0 - (event.clientY / canvas.height);
    deltaX = 0;
    deltaY = 0;
    mouseDown = true;
    count = 0;
    totalDX = 0;
    totalDY = 0;
}, false);

window.addEventListener('pointermove', function (event) {
    if (!mouseDown) {return}
    deltaX = event.clientX / canvas.width - mouseX;
    deltaY = 1.0 - (event.clientY / canvas.height) - mouseY;
    mouseX = event.clientX / canvas.width;
    mouseY = 1.0 - (event.clientY / canvas.height);
    /*if ((initialDirection == 0.0) && (document.getElementById("lock").checked)) {
        initialDirection = Math.atan(deltaY/deltaX) / ( 2.0 * Math.PI);
        console.log(initialDirection)
        if (initialDirection == 0.0) {initialDirection = 0.01;}
    }*/
    if ((count < 10) &&  (document.getElementById("lock").checked)) {
        totalDX += deltaX;
        totalDY += deltaY;
        initialDirection = -(Math.atan2(totalDX, totalDY) / (2 * Math.PI) + 0.75);
        while (initialDirection < 0) {initialDirection += 1}
        if (initialDirection == 0.) {initialDirection += 0.01}
        count += 1;
    }
    if (!toggle) {
        requestAnimationFrame(render);
    }
    }, false);

window.addEventListener('pointerup', function (event) {
    mouseDown = false;
    //deltaX = event.clientX / canvas.width - mouseX;
    //deltaY = 1.0 - (event.clientY / canvas.height) - mouseY;
    //console.log(mouseX, mouseY, deltaX, deltaY);
}, false);

// these 2 might've had to do with working on mobile, I think they prevent scrolling
canvas.addEventListener('pointerdown', function (event) {
    event.preventDefault();
}, false);

canvas.addEventListener('pointermove', function (event) {
    if (!mouseDown) {return}
    event.preventDefault();
}, false);








function initializeCoord(x, y) {
    return {'x': x ? x : Math.random(), 'y': y ? y : Math.random()}
}

// create sprites
function initializeSprite(location, velocity, velocityPreference, direction, start, limits) {
    var sprite = {
        'location': location ? location : initializeCoord(),
        'velocity': velocity ? velocity : Math.random(),
        'velocityPreference': velocityPreference ? velocityPreference : Math.random(),
        'direction': direction ? direction : 2.0 * Math.random() * Math.PI,
        'start': start ? start : Math.random(),
        'limits': limits ? limits : initializeCoord(),
        'lastLocation': undefined,
        'update': function() {
            this.lastLocation = this.location,
            this.location = initializeCoord(
                (((this.location.x + 2. * this.velocity * Math.cos(this.direction) * ((height / width)/(1 + height / width)) / 300) % 1.0) + 1.0) % 1.0,
                (((this.location.y + 2. * this.velocity * Math.sin(this.direction) * (1 /(1 + height / width)) / 300) % 1.0) + 1.0) % 1.0),
            this.velocity = 0.5 * this.velocity + 0.1 * this.velocityPreference + 0.4 * Math.random(),
            this.direction = (Math.pow(Math.random() * 2.0 - 1.0, 51.0) * Math.PI + this.direction) // very fly-like, in a bad way lol
            }
        }
    return sprite;
}

// nice, very polite
/*function update(sprite) {
    return {...sprite,...{
        'lastLocation' : sprite.location,
        'location' : initializeCoord(
            (((sprite.location.x + sprite.velocity * Math.cos(sprite.direction) / 300) % 1.0) + 1.0) % 1.0,
            (((sprite.location.y + sprite.velocity * Math.sin(sprite.direction) / 300) % 1.0) + 1.0) % 1.0),
        'velocity' : 0.5 * sprite.velocity + 0.1 * sprite.velocityPreference + 0.4 * Math.random(),
        'direction' : (Math.pow(Math.random() * 2.0 - 1.0, 9.0) * Math.PI / 10.0 + sprite.direction)
    }}
}*/

/*
function update(sprite) {
    return {...sprite,...{
        'lastLocation' : sprite.location,
        'location' : initializeCoord(
            (((sprite.location.x + sprite.velocity * Math.cos(sprite.direction) / 100) % 1.0) + 1.0) % 1.0,
            (((sprite.location.y + sprite.velocity * Math.sin(sprite.direction) / 100) % 1.0) + 1.0) % 1.0),
        'velocity' : 0.5 * sprite.velocity + 0.1 * sprite.velocityPreference + 0.4 * Math.random(),
        'direction' : (Math.pow(Math.random() * 2.0 - 1.0, 1.0) * Math.PI / 10.0 + sprite.direction)
    }}
}*/

/*
function update(sprite) {
    return {...sprite,...{
        'lastLocation' : sprite.location,
        'location' : initializeCoord(
            (((sprite.location.x + 2. * sprite.velocity * Math.cos(sprite.direction) * ((height / width)/(1 + height / width)) / 300) % 1.0) + 1.0) % 1.0,
            (((sprite.location.y + 2. * sprite.velocity * Math.sin(sprite.direction) * (1 /(1 + height / width)) / 300) % 1.0) + 1.0) % 1.0),
        'velocity' : 0.5 * sprite.velocity + 0.1 * sprite.velocityPreference + 0.4 * Math.random(),
        'direction' : (Math.pow(Math.random() * 2.0 - 1.0, 51.0) * Math.PI + sprite.direction) // very fly-like, in a bad way lol
    }}
}*/

var sprite1 = initializeSprite();








// create shaders
const vertexShaderSource = '#version 300 es' + document.getElementById('vertex').text;;
const advectFragShader = '#version 300 es \n precision highp float;' + document.getElementById('colors').text + document.getElementById('advection').text;
const divergenceFragShader = '#version 300 es \n precision highp float;' + document.getElementById('divergence').text;
const jacobiFragShader = '#version 300 es \n precision highp float;' + document.getElementById('jacobi').text;
const pressureFragShader = '#version 300 es \n precision highp float;' + document.getElementById('pressure').text;
const postprocessFragShader = '#version 300 es \n precision highp float;' + document.getElementById('colors').text + document.getElementById('postprocess').text;
const outputFragShader = '#version 300 es \n precision highp float;' + document.getElementById('output').text;

var advectionShader = {
    'program': webglUtils.createProgramFromSources(gl,[vertexShaderSource, advectFragShader])
}
advectionShader = {...advectionShader,...{
    'attributes': {
        'a_position': gl.getAttribLocation(advectionShader.program, "a_position"),
        'a_texCoord': gl.getAttribLocation(advectionShader.program, "a_texCoord")
    },
    'uniforms': {
        'deltaT': gl.getUniformLocation(advectionShader.program, "deltaT"),
        'dt': gl.getUniformLocation(advectionShader.program, "dt"),
        'u_resolution': gl.getUniformLocation(advectionShader.program, "u_resolution"),
        'u_image': gl.getUniformLocation(advectionShader.program, "u_image"),
        'velocity': gl.getUniformLocation(advectionShader.program, "velocity"),
        'mouseDown': gl.getUniformLocation(advectionShader.program, "mouseDown"),
        'glitter': gl.getUniformLocation(advectionShader.program, "glitter"),
        'toggle': gl.getUniformLocation(advectionShader.program, "toggle"),
        'initialDirection': gl.getUniformLocation(advectionShader.program, "initialDirection"),
        'paint': gl.getUniformLocation(advectionShader.program, "paint"),
        'dark': gl.getUniformLocation(advectionShader.program, "dark"),
        'change': gl.getUniformLocation(advectionShader.program, "change"),
        'center': gl.getUniformLocation(advectionShader.program, "center"),
        'radius': gl.getUniformLocation(advectionShader.program, "radius"),
        'time': gl.getUniformLocation(advectionShader.program, "time"),
        'spriteChange': gl.getUniformLocation(advectionShader.program, "spriteChange"),
        'spriteCenter': gl.getUniformLocation(advectionShader.program, "spriteCenter")
        }
}}

var divergenceShader = {
    'program': webglUtils.createProgramFromSources(gl,[vertexShaderSource, divergenceFragShader])
}
divergenceShader = {...divergenceShader,...{
    'attributes': {
        'a_position': gl.getAttribLocation(divergenceShader.program, "a_position"),
        'a_texCoord': gl.getAttribLocation(divergenceShader.program, "a_texCoord")
    },
    'uniforms': {
        'deltaT': gl.getUniformLocation(divergenceShader.program, "deltaT"),
        'rho': gl.getUniformLocation(divergenceShader.program, "rho"),
        'epsilon': gl.getUniformLocation(divergenceShader.program, "epsilon"),
        'velocity': gl.getUniformLocation(divergenceShader.program, "velocity"),
        'u_resolution': gl.getUniformLocation(divergenceShader.program, "u_resolution")
        }
}}

var jacobiShader = {
    'program': webglUtils.createProgramFromSources(gl,[vertexShaderSource, jacobiFragShader])
}
jacobiShader = {...jacobiShader,...{
    'attributes': {
        'a_position': gl.getAttribLocation(jacobiShader.program, "a_position"),
        'a_texCoord': gl.getAttribLocation(jacobiShader.program, "a_texCoord")
    },
    'uniforms': {
        'divergence': gl.getUniformLocation(jacobiShader.program, "divergence"),
        'pressure': gl.getUniformLocation(jacobiShader.program, "pressure"),
        'epsilon': gl.getUniformLocation(jacobiShader.program, "epsilon"),
        'u_resolution': gl.getUniformLocation(jacobiShader.program, "u_resolution")
        }
}}

var pressureShader = {
    'program': webglUtils.createProgramFromSources(gl,[vertexShaderSource, pressureFragShader])
}
pressureShader = {...pressureShader,...{
    'attributes': {
        'a_position': gl.getAttribLocation(pressureShader.program, "a_position"),
        'a_texCoord': gl.getAttribLocation(pressureShader.program, "a_texCoord")
    },
    'uniforms': {
        'u_resolution': gl.getUniformLocation(pressureShader.program, "u_resolution"),
        'rho': gl.getUniformLocation(pressureShader.program, "rho"),
        'pressure': gl.getUniformLocation(pressureShader.program, "pressure"),
        'epsilon': gl.getUniformLocation(pressureShader.program, "epsilon"),
        'deltaT': gl.getUniformLocation(pressureShader.program, "deltaT"),
        'velocity': gl.getUniformLocation(pressureShader.program, "velocity"),
        'mouseDown': gl.getUniformLocation(pressureShader.program, "mouseDown"),
        'toggle': gl.getUniformLocation(pressureShader.program, "toggle"),
        'change': gl.getUniformLocation(pressureShader.program, "change"),
        'center': gl.getUniformLocation(pressureShader.program, "center"),
        'radius': gl.getUniformLocation(pressureShader.program, "radius"),
        'spriteChange': gl.getUniformLocation(pressureShader.program, "spriteChange"),
        'spriteCenter': gl.getUniformLocation(pressureShader.program, "spriteCenter")
        }
}}

var postprocessShader = {
    'program': webglUtils.createProgramFromSources(gl,[vertexShaderSource, postprocessFragShader])
}
postprocessShader = {...postprocessShader,...{
    'attributes': {
        'a_position': gl.getAttribLocation(postprocessShader.program, "a_position"),
        'a_texCoord': gl.getAttribLocation(postprocessShader.program, "a_texCoord")
    },
    'uniforms': {
        'u_resolution': gl.getUniformLocation(postprocessShader.program, "u_resolution"),
        'epsilon': gl.getUniformLocation(postprocessShader.program, "epsilon"),
        'time': gl.getUniformLocation(postprocessShader.program, "time"),
        'mode': gl.getUniformLocation(postprocessShader.program, "mode")
        }
}}

var outputShader = {
    'program': webglUtils.createProgramFromSources(gl,[vertexShaderSource, outputFragShader])
}
outputShader = {...outputShader,...{
    'attributes': {
        'a_position': gl.getAttribLocation(outputShader.program, "a_position"),
        'a_texCoord': gl.getAttribLocation(outputShader.program, "a_texCoord")
    },
    'uniforms': {
        'u_resolution': gl.getUniformLocation(outputShader.program, "u_resolution")
        }
}}








// resizes canvas and textures, as well as initializes them
function resizeCanvas() {
    
    //width = window.innerWidth / scaleFactor;
    //height = window.innerHeight / scaleFactor;
    width = window.innerWidth / slider3.value();
    height = window.innerHeight / slider3.value();
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    gl.viewport(0, 0, width, height);

    targetVelocity = initTexture(gl.RG16F, gl.RG, gl.FLOAT);

    // initialize if not already done so
    if (texture == undefined) {

        texture = initTexture(gl.RG16F, gl.RG, gl.FLOAT);
        initialImage = initTexture(gl.RGBA16F, gl.RGBA, gl.FLOAT);

    }

    // if these two textures already exist, make them resized versions of what they should be
    else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

        texture = initTexture(gl.RG16F, gl.RG, gl.FLOAT);
        initShader(outputShader, [newInitialVelocity], texture);
        gl.uniform2f(outputShader.uniforms.u_resolution, width, height);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

        initialImage = initTexture(gl.RGBA16F, gl.RGBA, gl.FLOAT);
        initShader(outputShader, [realOutput2], initialImage, true);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.drawArrays(gl.TRIANGLES, 0, 6);

    }

    newInitialVelocity = initTexture(gl.RG16F, gl.RG, gl.FLOAT);
    realOutput = initTexture(gl.RGBA16F, gl.RGBA, gl.FLOAT);
    realOutput2 = initTexture(gl.RGBA16F, gl.RGBA, gl.FLOAT);
    divergence = initTexture(gl.R16F, gl.RED, gl.FLOAT);
    pressure = initTexture(gl.R16F, gl.RED, gl.FLOAT);
    pressurep = initTexture(gl.R16F, gl.RED, gl.FLOAT);
}

// all of these shaders use frame buffers, so a frame buffer must be bound before initializing shaders
function initShader(shader, inTex, outTex, isActive) {
    for (let i = 0; i < inTex.length; i++) {
        gl.activeTexture(gl.TEXTURE0+i);
        gl.bindTexture(gl.TEXTURE_2D, inTex[i]);
    }

    if (outTex) gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, outTex, 0);

    if (!isActive) {
        gl.useProgram(shader.program);

        gl.enableVertexAttribArray(shader.attributes.a_position);              // turn on the attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);                     // bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
        gl.vertexAttribPointer(                                            // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
            shader.attributes.a_position, 2, gl.FLOAT, false, 0, 0);

        gl.enableVertexAttribArray(shader.attributes.a_texCoord);              // Turn on the attribute
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        gl.vertexAttribPointer(                                             // Tell the attribute how to get data out of texCoordBuffer (ARRAY_BUFFER)
            shader.attributes.a_texCoord, 2, gl.FLOAT, false, 0, 0);
        }
    
     gl.activeTexture(gl.TEXTURE0 + 0);
    }

function initTexture(internalFormat, format, type) {

    // Create a texture to render to
    //var targetTexWidth = gl.canvas.width / scaleFactor;
    //var targetTexHeight = gl.canvas.height / scaleFactor;
    var targetTexWidth = gl.canvas.width / slider3.value();
    var targetTexHeight = gl.canvas.height / slider3.value();
    var targetTex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, targetTex);

    // define size and format of level 0
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, targetTexWidth, targetTexHeight, 0, format, type, null);
    
    // set the filtering so we don't need mips
    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

    return targetTex;
}









// create buffers
const positionBuffer = gl.createBuffer();
const texCoordBuffer = gl.createBuffer();
const frameBuffer = gl.createFramebuffer();

// create textures
var texture,
initialImage,
targetVelocity,
newInitialVelocity,
realOutput,
realOutput2,
divergence,
pressure,
pressurep,
temp;

var oldTime = 0;
var dt = 0;

function init(time) {
    time = time || 0;            

    //width = window.innerWidth / scaleFactor;
    //height = window.innerHeight / scaleFactor;

    width = window.innerWidth / slider3.value();
    height = window.innerHeight / slider3.value();

    // create a position buffer and put a rectangle that covers the whole space (i.e. make two triangles)
    gl.enableVertexAttribArray(advectionShader.attributes.a_position);              // turn on the attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);                     // bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
    gl.vertexAttribPointer(                                             // tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
        advectionShader.attributes.a_position, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(advectionShader.attributes.a_texCoord);              // Turn on the attribute
    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0.0, 0.0,
        1.0, 0.0,
        0.0, 1.0,
        0.0, 1.0,
        1.0, 0.0,
        1.0, 1.0,
    ]), gl.STATIC_DRAW);
    gl.vertexAttribPointer(                                             // Tell the attribute how to get data out of texCoordBuffer (ARRAY_BUFFER)
        advectionShader.attributes.a_texCoord, 2, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    setRectangle(gl, 0, 0, width, height);
    
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

    resizeCanvas();

    initShader(advectionShader, [texture, texture], targetVelocity);
    gl.uniform1f(advectionShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform1f(advectionShader.uniforms.dt, dt);
    gl.uniform1f(advectionShader.uniforms.paint, false);
    gl.uniform2f(advectionShader.uniforms.radius, 1.0/width, 1.0/height);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    // attach texture to framebuffer & attach the texture as the first color attachment
    initShader(divergenceShader, [targetVelocity], divergence);
    gl.uniform2f(divergenceShader.uniforms.u_resolution, width, height);
    gl.uniform1f(divergenceShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform2f(divergenceShader.uniforms.epsilon, 1.0/width, 1.0/height);
    gl.uniform1f(divergenceShader.uniforms.rho, slider2.value());
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    initShader(jacobiShader, [divergence, pressure], pressurep);
    gl.uniform2f(jacobiShader.uniforms.u_resolution, width, height);
    gl.uniform2f(jacobiShader.uniforms.epsilon, 1.0/width, 1.0/height);
    gl.uniform1i(jacobiShader.uniforms.divergence, 0);
    gl.uniform1i(jacobiShader.uniforms.pressure, 1);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    for (let i = 0; i < 2; i++) {

        temp = pressurep;
        pressurep = pressure;
        pressure = temp;

        initShader(jacobiShader, [divergence, pressure], pressurep, true);
        gl.uniform2f(jacobiShader.uniforms.u_resolution, width, height);
        gl.uniform2f(jacobiShader.uniforms.epsilon, 1.0/width, 1.0/height);
        gl.uniform1i(jacobiShader.uniforms.divergence, 0);
        gl.uniform1i(jacobiShader.uniforms.pressure, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    initShader(pressureShader, [targetVelocity, pressurep], newInitialVelocity);
    gl.uniform2f(pressureShader.uniforms.u_resolution, width, height);
    gl.uniform2f(pressureShader.uniforms.epsilon, 1.0/width, 1.0/height); 
    gl.uniform1f(pressureShader.uniforms.rho, 1.);
    gl.uniform1f(pressureShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform1i(pressureShader.uniforms.velocity, 0);
    gl.uniform1i(pressureShader.uniforms.pressure, 1);
    gl.uniform1f(pressureShader.uniforms.mouseDown, mouseDown);
    gl.uniform1f(pressureShader.uniforms.toggle, toggle);
    gl.uniform2f(pressureShader.uniforms.change, deltaX, deltaY);
    gl.uniform2f(pressureShader.uniforms.center, mouseX, mouseY);
    gl.uniform2f(pressureShader.uniforms.radius, 1.0/width, 1.0/height);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    initShader(advectionShader, [initialImage, newInitialVelocity], realOutput);
    gl.uniform2f(advectionShader.uniforms.u_resolution, width, height);
    gl.uniform1f(advectionShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform1f(advectionShader.uniforms.dt, dt);
    gl.uniform1i(advectionShader.uniforms.u_image, 0);
    gl.uniform1i(advectionShader.uniforms.velocity, 1);
    gl.uniform1f(advectionShader.uniforms.paint, true);
    gl.uniform1f(advectionShader.uniforms.dark, localStorage.theme == "dark");
    gl.uniform1f(advectionShader.uniforms.mouseDown, mouseDown);
    gl.uniform1f(advectionShader.uniforms.glitter, document.getElementById("glitter").checked);
    gl.uniform1f(advectionShader.uniforms.toggle, toggle);
    gl.uniform1f(advectionShader.uniforms.initialDirection, initialDirection);
    gl.uniform2f(advectionShader.uniforms.change, deltaX, deltaY);
    gl.uniform2f(advectionShader.uniforms.center, mouseX, mouseY);
    //canvas.width/1000000, canvas.height/1000000); // these might fix some things
    gl.uniform1f(advectionShader.uniforms.time, time);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    temp = realOutput;
    realOutput = realOutput2;
    realOutput2 = temp;

    if (toggle) {render();}
}

function display(time) {

    switch(mode) {
        case 0: initShader(postprocessShader, [realOutput]); break;
        case 1: initShader(postprocessShader, [pressure]); break;
        case 2: initShader(postprocessShader, [divergence]); break;
        case 3: initShader(postprocessShader, [newInitialVelocity]); break;
    }
    gl.uniform2f(postprocessShader.uniforms.u_resolution, width, height);
    gl.uniform1i(postprocessShader.uniforms.u_image, 0);
    gl.uniform2f(postprocessShader.uniforms.epsilon, 1.0/width, 1.0/height);
    gl.uniform1i(postprocessShader.uniforms.mode, mode);
    gl.uniform1f(postprocessShader.uniforms.time, time);

    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
}

function render(time) {

    //console.log(localStorage.theme);
    //console.log(getComputedStyle(document.documentElement));

    if (spriteOnOff && toggle) {sprite1.update();}
    gl.viewport(0, 0, width, height);

    //console.log(dt);
    
    // 1 / 60 is the regular frame rate... don't use dt for deltaT, it doesn't help slow computers, it's just makes the rendering wacky
    dt = time - oldTime;
    oldTime = time;

    //console.log(time);

    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);

    initShader(advectionShader, [newInitialVelocity, newInitialVelocity], targetVelocity);
    gl.uniform1f(advectionShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform1f(advectionShader.uniforms.dt, dt);
    gl.uniform1f(advectionShader.uniforms.paint, false);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    initShader(divergenceShader, [targetVelocity], divergence);
    gl.uniform1f(divergenceShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform1f(divergenceShader.uniforms.rho, slider2.value());
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    initShader(jacobiShader, [divergence, pressure], pressurep);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    for (let i = 0; i < 10; i++) {
        temp = pressurep;
        pressurep = pressure;
        pressure = temp;
        initShader(jacobiShader, [divergence, pressure], pressurep, true);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    initShader(pressureShader, [targetVelocity, pressurep], newInitialVelocity);
    gl.uniform1f(pressureShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform1f(pressureShader.uniforms.mouseDown, mouseDown);
    gl.uniform1f(pressureShader.uniforms.toggle, toggle);
    gl.uniform2f(pressureShader.uniforms.change, deltaX, deltaY);
    gl.uniform2f(pressureShader.uniforms.center, mouseX, mouseY);
    gl.uniform2f(pressureShader.uniforms.spriteChange, sprite1.location.x - sprite1.lastLocation.x, sprite1.location.y - sprite1.lastLocation.y);
    gl.uniform2f(pressureShader.uniforms.spriteCenter, sprite1.location.x, sprite1.location.y);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    if (mouseDown) {console.log(deltaX, deltaY, 1/width, 1/height);}

    initShader(advectionShader, [realOutput2, newInitialVelocity], realOutput);
    gl.uniform1f(advectionShader.uniforms.deltaT, slider.value() / 60);
    gl.uniform1f(advectionShader.uniforms.paint, true);
    gl.uniform1f(advectionShader.uniforms.dark, localStorage.theme == "dark");
    gl.uniform1f(advectionShader.uniforms.mouseDown, mouseDown);
    gl.uniform1f(advectionShader.uniforms.glitter, document.getElementById("glitter").checked);
    gl.uniform1f(advectionShader.uniforms.toggle, toggle);
    gl.uniform1f(advectionShader.uniforms.initialDirection, initialDirection);
    gl.uniform2f(advectionShader.uniforms.change, deltaX, deltaY);
    gl.uniform2f(advectionShader.uniforms.center, mouseX, mouseY);
    gl.uniform1f(advectionShader.uniforms.time, time % 100000);
    gl.uniform2f(advectionShader.uniforms.spriteChange, sprite1.location.x - sprite1.lastLocation.x, sprite1.location.y - sprite1.lastLocation.y);
    gl.uniform2f(advectionShader.uniforms.spriteCenter, sprite1.location.x, sprite1.location.y);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.drawArrays(gl.TRIANGLES, 0, 6);

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);

    //mode = parseInt(document.querySelector('input[name="mode"]:checked').value);

    display(time);

    temp = realOutput;
    realOutput = realOutput2;
    realOutput2 = temp;

    // this fixes the sticky issue on mobile, I might want to toggle this!
    deltaX = 0;
    deltaY = 0;

    //console.log(toggle)

    if (toggle) requestAnimationFrame(render);
}

function setRectangle(gl, x, y, width, height) {
    var x1 = x;
    var x2 = x + width;
    var y1 = y;
    var y2 = y + height;
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        x1, y1,
        x2, y1,
        x1, y2,
        x1, y2,
        x2, y1,
        x2, y2,
    ]), gl.STATIC_DRAW);
}







// slider stuff mostly

var data = [0, 1.0];
var slider = d3.sliderBottom()
    .min(0.1)
    .max(2.0)
    .width(Math.min(300,screen.width*0.55))
    .tickFormat(d3.format('.0%'))
    .ticks(5)
    .default(1.0)
    .fill('#008c')
    .handle(d3.symbol()
        .type(d3.symbolCircle)
        .size(250)
    )
var gFill = d3.select('div#slider-fill')
    .append('svg')
    .attr('width', Math.min(350,screen.width*0.7))
    .attr('height', 65)
var gFillg = gFill
    .append('g')
    .attr('transform', 'translate(30,30)')
    .attr('fill', '#aaaaaa')
gFillg.call(slider);

var slider2 = d3.sliderBottom()
    .min(0.1)
    .max(2.0)
    .width(Math.min(300,screen.width*0.55))
    .tickFormat(d3.format('.0%'))
    .ticks(5)
    .default(1.0)
    .fill('#008c')
    .handle(d3
        .symbol()
        .type(d3.symbolCircle)
        .size(250)
    )
var gFill2 = d3.select('div#slider-fill2')
    .append('svg')
    .attr('width', Math.min(350,screen.width*0.7))
    .attr('height', 65)
var gFillg2 = gFill2.append('g')
    .attr('transform', 'translate(30,30)')
    .attr('fill', '#aaaaaa');
gFillg2.call(slider2);

var slider3 = d3.sliderBottom()
    .min(1.0)
    .max(32.0)
    .width(Math.min(300,screen.width*0.55))
    .ticks(5)
    .default(4.0)
    .fill('#008c')
    .handle(d3
        .symbol()
        .type(d3.symbolCircle)
        .size(250)
    )
    .on('onchange', function() {
    toggle = false; // make sure it's not trying to render while updating the rendering settings
    if(!(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))){updateWindow();}
    else{ // on iPhone at least, it will resize when the address bar hides. I want that to be the size of the canvas, and then I never want it to change
        if ((window.innerWidth > canvas.width) || (window.innerHeight > canvas.height)){updateWindow()}
        //else{updateWindow()} // this is only for debugging
    }
    toggle = true;
    });
var gFill3 = d3.select('div#slider-fill3')
    .append('svg')
    .attr('width', Math.min(350,screen.width*0.7))
    .attr('height', 65)
var gFillg3 = gFill3.append('g')
    .attr('transform', 'translate(30,30)')
    .attr('fill', '#aaaaaa')
gFillg3.call(slider3);



function activateSwitch() {
        toggle = !toggle;
        if (toggle) {
            btn.textContent = '⏸';
            //updateWindow(); // I could've just had render(), but this will also make sure that there exists a way to make sure the screen is adequate
            // actually updating the window freaks out the pressure... FIGURE OUT WHY!!!
        }
        else {
            btn.textContent = '▶️';
        }
        render();
    }

function keySwitch() {
    switch(event.keyCode) {
        case 190:
            if (toggle) {activateSwitch()}
            else {requestAnimationFrame(render)}
            break
        case 77: 
            document.getElementById("radio_main").checked = true
            mode = 0
            requestAnimationFrame(display)
            break
        case 80: 
            document.getElementById("radio_pressure").checked = true
            mode = 1
            requestAnimationFrame(display);
            break
        case 68: 
            document.getElementById("radio_divergence").checked = true
            mode = 2
            requestAnimationFrame(display);
            break
        case 86: 
            document.getElementById("radio_velocity").checked = true
            mode = 3
            requestAnimationFrame(display);
            break
        case 83: 
            document.getElementById("sprite").checked = !document.getElementById("sprite").checked
            spriteOnOff = document.getElementById("sprite").checked
            if (!spriteOnOff) {sprite1.lastLocation = sprite1.location}
            break
        case 71: 
            document.getElementById("glitter").checked = !document.getElementById("glitter").checked
            break
        case 76: 
            document.getElementById("lock").checked = !document.getElementById("lock").checked
            break
        default: activateSwitch()

    }
}


btn.addEventListener('click', activateSwitch);
window.addEventListener('keydown', keySwitch);


radiobtn.addEventListener('click', function () {
    mode = parseInt(document.querySelector('input[name="mode"]:checked').value);
    requestAnimationFrame(display);
});

document.getElementById("sprite").addEventListener('click', function () {
    spriteOnOff = document.getElementById("sprite").checked;
    if (!spriteOnOff) {sprite1.lastLocation = sprite1.location}
});

// only other thing worth caring about
window.onload = function() {init()}

function updateWindow(){
    slider.width(Math.min(300,screen.width*0.55));
    gFill.attr('width', Math.min(350,screen.width*0.7));
    gFillg.call(slider);
    slider2.width(Math.min(300,screen.width*0.55));
    gFill2.attr('width', Math.min(350,screen.width*0.7));
    gFillg2.call(slider2);
    init();
}

d3.select(window).on('resize.updatesvg', function() {
    toggle = false; // make sure it's not trying to render while updating the rendering settings
    if(!(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))){updateWindow();}
    else{ // on iPhone at least, it will resize when the address bar hides. I want that to be the size of the canvas, and then I never want it to change
        if ((window.innerWidth > canvas.width) || (window.innerHeight > canvas.height)){updateWindow()}
        //else{updateWindow()} // this is only for debugging
    }
    toggle = true;
    });

const freeSpace = document.getElementById('space');
freeSpace.addEventListener('touchstart', function(e){ e.preventDefault(); }, {passive:false});
freeSpace.addEventListener('touchmove', function(e){ e.preventDefault(); }, {passive:false});
    
</script>
<h1 id="information">Information</h1>
<p>  The colors emitted by the cursor are determined by both the direction and the speed of the drag. The “Glitter” setting adds more variance to the colors and “Lock Color Direction” causes the colors to be determined only by the <em>initial</em> direction of the drag.</p>
<p>  There is a play/pause button to turn on/off the smoke. However, you can also press any key on your keyboard that doesn’t match the first letter of the above settings to play/pause, and if you want to see changes one frame at a time you can press the period (&quot;.&quot;) key. Smoke can be emitted by the cursor even when paused.</p>
<p>  The sliders can change how the smoke works. The top slider changes how quickly the smoke spreads, and the middle slider varies the density of the smoke, effectively changing the way the smoke spreads where higher values seem to make it flow more like watercolor paint. The bottom slider changes the pixel size of the fluid.</p>
<p>  The buttons show what is going on under-the-hood controlling how the smoke moves, and are painted with multicolored gradients. In the case of both Pressure and Divergence, lighter green/yellow-red colors represent positive values and darker blue-magenta colors represent negative values. The gradients cycle between colors creating bands such that it either is linear where the $N$th band has
$N$ times the strength as the first band (as in the case of Pressure), or it has $\sqrt[4]{2^{N-1}}$ times the strength as the first band (as in the case of Divergence, i.e. it’s a logarithmic scale). Velocity is shaded such that every direction is prescribed its own hue, and the strength of the hue is the velocity in that direction.</p>
<h1 id="extra-details">Extra Details</h1>
<p>  The smoke shader should work both on desktop and on mobile, although it’s better on desktop. It is best rendered on chrome, as if your monitor is capable of rendering P3 colors (most macs can, for example) then the colors will render as P3 colors (giving a wider gamut, making even more colorful smoke and gradients!).</p>
<p>  Colors themselves are picked from the Okhsl color space, allowing for perceptually smoother gradients. The colors are technically floats, and while monitors do not normally render float values for colors, this allows for colors to be rendered extra smooth by adding a little noise, preventing banding.</p>
<p>  Click-and-drag actions are somewhat sinusoidal (with a bit of noise), for that reason when quick and long paths are made with your cursor the smoke will seemingly have a lot of texture.</p>
<p>  The smoke will also adjust easily to the screen changing sizes (although the smoke does behave slightly differently depending on the ratio of the dimensions, where it will spread farther across the wider dimension), so feel free to experiment with that as well.</p>

	</article>
</main>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"
  integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"
  integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
  integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
      ],
      
      throwOnError: false
    });
  });
</script>







  <footer class="mt-8 flex sm:flex-col-reverse justify-between items-center">
  <p class="mt-0 text-sm">
    TH ↔ Þ
  </p>
  <p class="flex items-center mt-0">
    
      <a class="icon mx-2" href="https://github.com/agaura" title="github">
      
        <svg fill="#63636f" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="https://www.instagram.com/arg793/" title="instagram">
      
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill = "#bc2a8d" d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="https://www.linkedin.com/in/alexander-gaura-19980514a/" title="linkedin">
      
        <svg fill="#0073b1" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="/index.xml" title="rss">
      
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill = "#ee802f" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg>
      
      </a>
    
  </p>
</footer>
</body>
</html>