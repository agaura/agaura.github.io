<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta property="og:url" content="https://agaura.github.io/color-space-point/">
  <meta property="og:site_name" content="Alexander Gaura">
  <meta property="og:title" content="Color Space Point Cloud">
  <meta property="og:description" content="Here is a point cloud containing $2^{15}$ particles for exploring the various color spaces (or, more accurately, exploring the projection of sRGB into these spaces). They have various purposes, but CIELab, OKLab, and CAM16-UCS are all designed to be perceptually uniform. This design is built to make it easy to see the differences and surprising variability between these three spaces, and contrast them against the famous sRGB space and the XYZ space (which is a convenient space for conversions and characterization of colors).">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:published_time" content="2023-07-26T11:26:07-04:00">
    <meta property="article:modified_time" content="2023-07-26T11:26:07-04:00">

  
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Color Space Point Cloud">
  <meta name="twitter:description" content="Here is a point cloud containing $2^{15}$ particles for exploring the various color spaces (or, more accurately, exploring the projection of sRGB into these spaces). They have various purposes, but CIELab, OKLab, and CAM16-UCS are all designed to be perceptually uniform. This design is built to make it easy to see the differences and surprising variability between these three spaces, and contrast them against the famous sRGB space and the XYZ space (which is a convenient space for conversions and characterization of colors).">

  
  
    
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-BBWS173BMQ"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-BBWS173BMQ');
        }
      </script>
    
  


  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#262d33">
  <title>
    
    Alexander Gaura - Color Space Point Cloud
    
  </title>
  
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;500;600;700&display=swap"
    rel="stylesheet">
  
  
  
  <link rel="stylesheet" href="/minima.1742165536.css">

  
  
  <script defer type="text/javascript" src="/minima.1742165536.js"></script>
</head>
<script>
  
  let theme_2b_used = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';

  try {
    if (!('theme' in localStorage)) {
      const default_theme = 'system';
      
      
      if (default_theme === 'dark' || default_theme === 'light') {
        theme_2b_used = default_theme;
      }

      
      localStorage.theme = theme_2b_used;
    }
    
    document.querySelector('html').classList.add(localStorage.theme);
  } catch (e) {
    console.error(e);
  }
</script>


<body class=" sm:mx-5 sm:my-0">
  <header class="flex justify-between items-center mb-6 sm:my-3">
  <div class="flex items-center">
    
    <div id="theme-switcher" class="text-4xl cursor-pointer">⚫️</div>
  </div>
  <nav class="flex items-center
    whitespace-nowrap overflow-x-auto overflow-y-hidden">
    
    <a class="ml-5" href="/">Home</a>
    
    <a class="ml-5" href="/categories/writing">Writing</a>
    
    <a class="ml-5" href="/categories/projects">Projects</a>
    
    <a class="ml-5" href="/about">About</a>
    
  </nav>
</header>
  
  

<h1 class="mt-6 mb-6">Color Space Point Cloud</h1>
<div class="mb-3 text-xs flex justify-between sm:flex-col">
	<div>
	
		Posted at &mdash; Jul 26, 2023
	
		
	</div>
	
</div>
<main>
	<p></p>
	<article class="md">
		<p>  Here is a point cloud containing $2^{15}$ particles for exploring the various color spaces (or, more accurately, exploring the projection of sRGB into these spaces). They have various purposes, but CIELab, OKLab, and CAM16-UCS are all designed to be perceptually uniform. This design is built to make it easy to see the differences and surprising variability between these three spaces, and contrast them against the famous sRGB space and the XYZ space (which is a convenient space for conversions and characterization of colors). NOTE: the scale of the spaces and their vertical positions are artbitrary and are chosen just for convenience of visualization. The design is more for comparing the general shape of the spaces.</p>
<p>  Use the sliders to change the focus, which highlights an individual color and colors nearby, and feel free to interact with the color space itself, it can be rotated by clicking and dragging on it.</p>
<p>  Additional sliders are given below for color blindness, where the dense region represents the subset of the space visible by someone with that type of color blindness, while the focused colors show the range of colors which someone of that type of color blindness may experience to be similar, causing the focus to take an elongated shape.</p>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="https://unpkg.com/d3-simple-slider"></script>
<div align="center" id='view'>
<br>
View:   <input type="checkbox" id="order" name="view" value="0">
<label for="0">Order</label>
<!--<input type="checkbox" id="truecloud" name="truecloud" >
<label for="1">True Cloud</label> -->
<input type="checkbox" id="verticallock" name="verticallock" checked="checked">
<label for="1">Vertical Lock</label>
<input type="checkbox" id="pole" name="pole" checked="checked">
<label for="1">Pole</label>
</div>
<div align="center" id='mode'>
<br>
Mode:   <input type="radio" id="rgb" name="mode" value="0">
<label for="0">sRGB</label>
<input type="radio" id="XYZ" name="mode" value="1">
<label for="1">XYZ</label>
<input type="radio" id="cielab" name="mode" value="2">
<label for="0">CIELab</label>
<input type="radio" id="oklab" name="mode" value="3" checked="checked">
<label for="1">OKLab</label>
<input type="radio" id="cam16" name="mode" value="4">
<label for="2">CAM16-UCS</label>
</div>
<div id ="div" align="center" onmouseover="this.style.cursor='pointer';" style="touch-action: none"><canvas text-align='center' id="canvas"></canvas></div>
<div align="center" id="sliders"></div>
<div align="center"/>
<br>
Focus:
<br>
<div align="center">
<br>
<input type="checkbox" id="isolate" name="isolate" >
<label for="0">Isolate</label>
<input type="checkbox" id="orientation" name="view" value="0">
<label for="1">Follow</label>
<br>
<!--
<input type="radio" id="sphere" name="focus" value="0" checked="checked">
<label for="1">Spherical</label>
<input type="radio" id="verticle" name="focus" value="1">
<label for="1">Vertical</label>
<input type="radio" id="horizontal" name="focus" value="2">
<label for="1">Horizontal</label> -->
</div>
<div align="center"/>
<br>Color Blindness: 
<br>
<div align="center" id='blindview'>   
<br>
<input type="checkbox" id="compact" name="compact" >
<label for="0">Compact View</label>
</div>
<div align="center" id='colorblindness'>   
<br>
<input type="radio" id="trichromacy" name="type" value="0" checked="checked">
<label for="0">Trichromacy</label>
<br>
<input type="radio" id="protanopia" name="type" value="1">
<label for="1">Protanopia</label>
<input type="radio" id="deuteranopia" name="type" value="2">
<label for="1">Deuteranopia</label>
<input type="radio" id="tritanopia" name="type" value="3">
<label for="1">Tritanopia</label>
<br>
<input type="radio" id="achromatopsia" name="type" value="4">
<label for="1">Achromatopsia</label>
<br>
<!--
<input type="radio" id="lightblindness" name="type" value="5">
<label for="1">Lightness Blindness (impossible/for fun)</label> -->
</div>
<div align="center" id="sliders2"></div>
<svg id = "hue" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
    <linearGradient id="Gradient2" x1="0" x2="0" y1="0" y2="1">
        <stop offset="0%" stop-color="#d60071b0" />
        <stop offset="20%" stop-color="#c04e00b0" />
        <stop offset="30%" stop-color="#917200b0" />
        <stop offset="45%" stop-color="#468a00b0" />
        <stop offset="50%" stop-color="#008a79b0" />
        <stop offset="60%" stop-color="#0083a8b0" />
        <stop offset="70%" stop-color="#4b5dffb0" />
        <stop offset="100%" stop-color="#b200dfb0" />
    </linearGradient>
<path fill="url(#Gradient2)" d="M12 0c-4.87 7.197-8 11.699-8 16.075 0 4.378 3.579 7.925 8 7.925s8-3.547 8-7.925c0-4.376-3.13-8.878-8-16.075zm.462 20.471c2.56-1.049 4.124-4.889 3.021-8.853 3.798 4.909.754 9.393-3.021 8.853z" /></svg>
<p><svg id="sat" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"> <path fill='gray' d="M22.266 14.724c-.064.898-.242 1.766-.522 2.586l1.601.675c-.163.461-.353.909-.568 1.344l-1.602-.676c-.383.751-.855 1.448-1.402 2.078l1.229 1.229c-.323.364-.667.709-1.032 1.032l-2.262-2.262c1.874-1.59 3.125-4.039 3.125-6.735 0-4.878-3.954-8.832-8.832-8.832s-8.833 3.954-8.833 8.832c0 2.505 1.107 5.024 3.126 6.735l-2.293 2.27-1.031-1.031 1.259-1.238c-.562-.647-1.046-1.365-1.434-2.139l-1.606.665c-.212-.436-.399-.885-.559-1.348l1.605-.664c-.268-.802-.439-1.646-.5-2.521h-1.735v-1.459h1.734c.063-.897.242-1.765.522-2.585l-1.6-.675c.163-.461.352-.91.567-1.344l1.602.675c.383-.75.855-1.448 1.403-2.078l-1.229-1.229c.323-.365.668-.709 1.032-1.031l1.229 1.229c.647-.562 1.366-1.045 2.141-1.433l-.665-1.606c.435-.212.885-.399 1.347-.558l.665 1.604c.802-.267 1.647-.438 2.522-.5v-1.734h1.459v1.733c.899.063 1.767.242 2.587.522l.675-1.6c.462.162.911.353 1.345.567l-.676 1.602c.751.383 1.449.854 2.08 1.402l1.229-1.229c.365.322.709.666 1.032 1.03l-1.229 1.229c.562.647 1.045 1.366 1.434 2.14l1.606-.665c.212.436.399.885.558 1.348l-1.604.664c.269.802.439 1.646.501 2.521h1.733v1.459h-1.734zm-3.434-.729c0 3.767-3.064 6.832-6.832 6.832s-6.833-3.065-6.833-6.832 3.065-6.832 6.833-6.832 6.832 3.065 6.832 6.832zm-7.36-1.81l-2.158-2.158-1.415 1.413 2.158 2.158 1.415-1.413z"/></svg></p>
<svg id="val" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
        <path fill='gray'
            d="M14 19h-4c-.276 0-.5.224-.5.5s.224.5.5.5h4c.276 0 .5-.224.5-.5s-.224-.5-.5-.5zm0 2h-4c-.276 0-.5.224-.5.5s.224.5.5.5h4c.276 0 .5-.224.5-.5s-.224-.5-.5-.5zm.25 2h-4.5l1.188.782c.154.138.38.218.615.218h.895c.234 0 .461-.08.615-.218l1.187-.782zm3.75-13.799c0 3.569-3.214 5.983-3.214 8.799h-1.989c-.003-1.858.87-3.389 1.721-4.867.761-1.325 1.482-2.577 1.482-3.932 0-2.592-2.075-3.772-4.003-3.772-1.925 0-3.997 1.18-3.997 3.772 0 1.355.721 2.607 1.482 3.932.851 1.478 1.725 3.009 1.72 4.867h-1.988c0-2.816-3.214-5.23-3.214-8.799 0-3.723 2.998-5.772 5.997-5.772 3.001 0 6.003 2.051 6.003 5.772zm4-.691v1.372h-2.538c.02-.223.038-.448.038-.681 0-.237-.017-.464-.035-.69h2.535zm-10.648-6.553v-1.957h1.371v1.964c-.242-.022-.484-.035-.726-.035-.215 0-.43.01-.645.028zm-3.743 1.294l-1.04-1.94 1.208-.648 1.037 1.933c-.418.181-.822.401-1.205.655zm10.586 1.735l1.942-1.394.799 1.115-2.054 1.473c-.191-.43-.423-.827-.687-1.194zm-3.01-2.389l1.038-1.934 1.208.648-1.041 1.941c-.382-.254-.786-.473-1.205-.655zm-10.068 3.583l-2.054-1.472.799-1.115 1.942 1.393c-.264.366-.495.763-.687 1.194zm13.707 6.223l2.354.954-.514 1.271-2.425-.982c.21-.397.408-.812.585-1.243zm-13.108 1.155l-2.356 1.06-.562-1.251 2.34-1.052c.173.433.371.845.578 1.243zm-1.178-3.676h-2.538v-1.372h2.535c-.018.226-.035.454-.035.691 0 .233.018.458.038.681z" /></svg>
<p><svg id="foc" fill="#000000" height="24" width="24" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" 
viewBox="0 0 512 512" xml:space="preserve">
<g>
<g>
<g>
<path fill='gray' d="M256,213.333c-23.573,0-42.667,19.093-42.667,42.667s19.093,42.667,42.667,42.667s42.667-19.093,42.667-42.667
S279.573,213.333,256,213.333z"/>
<path fill='gray' d="M213.227,317.895c-0.031-0.315-0.09-0.621-0.135-0.933c-0.054-0.377-0.098-0.756-0.173-1.13
c-0.071-0.358-0.169-0.704-0.258-1.055c-0.081-0.324-0.152-0.649-0.249-0.969c-0.104-0.344-0.233-0.677-0.354-1.013
c-0.115-0.32-0.22-0.642-0.35-0.957c-0.13-0.314-0.283-0.615-0.428-0.921c-0.153-0.325-0.297-0.653-0.468-0.971
c-0.157-0.293-0.336-0.572-0.506-0.857c-0.186-0.312-0.363-0.628-0.566-0.932c-0.211-0.315-0.446-0.612-0.673-0.915
c-0.19-0.254-0.366-0.514-0.569-0.761c-0.443-0.54-0.91-1.059-1.403-1.552c-0.004-0.004-0.006-0.008-0.01-0.011
c-0.004-0.004-0.008-0.007-0.012-0.011c-0.493-0.492-1.012-0.959-1.551-1.402c-0.247-0.203-0.508-0.379-0.762-0.57
c-0.303-0.227-0.6-0.462-0.915-0.673c-0.304-0.203-0.619-0.379-0.931-0.565c-0.286-0.171-0.565-0.35-0.859-0.507
c-0.318-0.17-0.645-0.314-0.97-0.467c-0.306-0.145-0.608-0.298-0.922-0.428c-0.315-0.13-0.637-0.236-0.957-0.35
c-0.337-0.121-0.669-0.25-1.013-0.354c-0.32-0.097-0.645-0.168-0.969-0.249c-0.351-0.089-0.698-0.187-1.056-0.258
c-0.375-0.074-0.753-0.118-1.13-0.172c-0.311-0.044-0.618-0.104-0.933-0.135c-0.701-0.069-1.404-0.106-2.107-0.106H85.333
C73.551,298.667,64,308.218,64,320s9.551,21.333,21.333,21.333h55.163L6.248,475.582c-8.331,8.331-8.331,21.839,0,30.17
c8.331,8.331,21.839,8.331,30.17,0l134.248-134.248v55.163c0,11.782,9.551,21.333,21.333,21.333s21.333-9.551,21.333-21.333
V320.001C213.333,319.298,213.296,318.595,213.227,317.895z"/>
<path fill='gray' d="M371.503,341.333h55.163c11.782,0,21.333-9.551,21.333-21.333s-9.551-21.333-21.333-21.333H320.001
c-0.703,0-1.406,0.037-2.107,0.106c-0.315,0.031-0.621,0.09-0.933,0.135c-0.377,0.054-0.756,0.098-1.13,0.173
c-0.358,0.071-0.704,0.169-1.055,0.258c-0.324,0.081-0.649,0.152-0.969,0.249c-0.344,0.104-0.677,0.233-1.013,0.354
c-0.32,0.115-0.642,0.22-0.957,0.35c-0.314,0.13-0.615,0.283-0.921,0.428c-0.325,0.153-0.653,0.297-0.971,0.468
c-0.293,0.157-0.572,0.336-0.857,0.506c-0.312,0.186-0.628,0.363-0.932,0.566c-0.315,0.211-0.611,0.445-0.913,0.671
c-0.255,0.191-0.516,0.368-0.764,0.571c-0.535,0.439-1.05,0.903-1.54,1.392c-0.008,0.007-0.016,0.014-0.023,0.021
s-0.014,0.016-0.021,0.023c-0.488,0.49-0.952,1.004-1.392,1.54c-0.204,0.248-0.38,0.509-0.571,0.764
c-0.226,0.302-0.461,0.598-0.671,0.913c-0.204,0.304-0.38,0.62-0.566,0.932c-0.17,0.285-0.349,0.564-0.506,0.857
c-0.17,0.318-0.315,0.646-0.468,0.971c-0.145,0.306-0.297,0.607-0.428,0.921c-0.13,0.315-0.236,0.637-0.35,0.957
c-0.121,0.337-0.25,0.669-0.354,1.013c-0.097,0.32-0.168,0.646-0.249,0.969c-0.089,0.351-0.187,0.698-0.258,1.055
c-0.074,0.375-0.118,0.753-0.173,1.13c-0.044,0.311-0.104,0.617-0.135,0.933c-0.069,0.7-0.106,1.403-0.106,2.105v106.667
c0,11.782,9.551,21.333,21.333,21.333s21.333-9.551,21.333-21.333v-55.163l134.248,134.248c8.331,8.331,21.839,8.331,30.17,0
c8.331-8.331,8.331-21.839,0-30.17L371.503,341.333z"/>
<path fill='gray' d="M298.908,195.039c0.054,0.377,0.098,0.755,0.172,1.13c0.071,0.358,0.169,0.705,0.258,1.056
c0.081,0.323,0.152,0.649,0.249,0.969c0.104,0.344,0.233,0.677,0.354,1.013c0.115,0.32,0.22,0.642,0.35,0.957
c0.13,0.314,0.283,0.616,0.428,0.922c0.153,0.325,0.297,0.652,0.467,0.97c0.157,0.294,0.337,0.573,0.507,0.859
c0.186,0.312,0.362,0.627,0.565,0.931c0.211,0.315,0.446,0.612,0.673,0.915c0.19,0.254,0.367,0.515,0.57,0.762
c0.443,0.539,0.909,1.058,1.402,1.551c0.004,0.004,0.007,0.008,0.011,0.012c0.004,0.004,0.008,0.006,0.011,0.01
c0.494,0.493,1.012,0.96,1.552,1.403c0.247,0.203,0.507,0.379,0.761,0.569c0.303,0.227,0.6,0.462,0.915,0.673
c0.304,0.204,0.62,0.38,0.932,0.566c0.285,0.17,0.564,0.349,0.857,0.506c0.318,0.17,0.646,0.315,0.971,0.468
c0.306,0.145,0.607,0.297,0.921,0.428c0.315,0.13,0.637,0.236,0.957,0.35c0.337,0.121,0.669,0.25,1.013,0.354
c0.32,0.097,0.646,0.168,0.969,0.249c0.351,0.089,0.698,0.187,1.055,0.258c0.375,0.074,0.753,0.118,1.13,0.173
c0.311,0.044,0.617,0.104,0.933,0.135c0.7,0.069,1.403,0.106,2.105,0.106h106.667c11.782,0,21.333-9.551,21.333-21.333
s-9.551-21.333-21.333-21.333h-55.163L505.752,36.418c8.331-8.331,8.331-21.839,0-30.17c-8.331-8.331-21.839-8.331-30.17,0
L341.333,140.497V85.333C341.333,73.551,331.782,64,320,64s-21.333,9.551-21.333,21.333V192c0,0.703,0.037,1.405,0.106,2.105
C298.804,194.421,298.863,194.727,298.908,195.039z"/>
<path fill='gray' d="M140.497,170.667H85.333C73.551,170.667,64,180.218,64,192s9.551,21.333,21.333,21.333H192
c0.703,0,1.405-0.037,2.105-0.106c0.315-0.031,0.622-0.09,0.933-0.135c0.377-0.054,0.755-0.098,1.13-0.172
c0.358-0.071,0.705-0.169,1.056-0.258c0.323-0.081,0.649-0.152,0.969-0.249c0.344-0.104,0.677-0.233,1.013-0.354
c0.32-0.115,0.642-0.22,0.957-0.35c0.314-0.13,0.616-0.283,0.922-0.428c0.325-0.153,0.652-0.297,0.97-0.467
c0.294-0.157,0.573-0.337,0.859-0.507c0.312-0.186,0.627-0.362,0.931-0.565c0.316-0.211,0.613-0.447,0.917-0.674
c0.253-0.19,0.513-0.365,0.759-0.568c1.087-0.892,2.085-1.889,2.977-2.977c0.202-0.246,0.378-0.506,0.568-0.759
c0.228-0.304,0.463-0.601,0.674-0.917c0.203-0.304,0.379-0.619,0.565-0.931c0.171-0.286,0.35-0.565,0.507-0.859
c0.17-0.318,0.314-0.645,0.467-0.97c0.145-0.306,0.298-0.608,0.428-0.922c0.13-0.315,0.236-0.637,0.35-0.957
c0.121-0.337,0.25-0.669,0.354-1.013c0.097-0.32,0.168-0.645,0.249-0.969c0.089-0.351,0.187-0.698,0.258-1.056
c0.074-0.375,0.118-0.753,0.172-1.13c0.044-0.311,0.104-0.618,0.135-0.933c0.069-0.701,0.106-1.404,0.106-2.107V85.333
C213.333,73.551,203.782,64,192,64s-21.333,9.551-21.333,21.333v55.163L36.418,6.248c-8.331-8.331-21.839-8.331-30.17,0
c-8.331,8.331-8.331,21.839,0,30.17L140.497,170.667z"/>
</g>
</g>
</g>
</svg></p>
<svg id="eye" width="30" height="30" viewBox="0 0 48 48" xmlns="http://www.w3.org/2000/svg">
  <title>accessibility-blind</title>
  <g id="Layer_2" data-name="Layer 2">
    <g id="invisible_box" data-name="invisible box">
      <rect width="48" height="48" fill="none"/>
    </g>
    <g id="icons_Q2" data-name="icons Q2">
      <g>
        <path d="M45.3,22.1C43.2,19.5,35.4,11,24,11a23,23,0,0,0-8.5,1.6L9.7,6.9A2,2,0,0,0,6.9,9.7L38.3,41.1a2,2,0,1,0,2.8-2.8l-4.7-4.8a32.1,32.1,0,0,0,8.9-7.6A3,3,0,0,0,45.3,22.1ZM33.4,30.6l-4-4A5.8,5.8,0,0,0,30,24a6,6,0,0,0-6-6,5.8,5.8,0,0,0-2.6.6l-2.8-2.8A19.1,19.1,0,0,1,24,15c8.8,0,15.3,6.2,17.7,9A29.7,29.7,0,0,1,33.4,30.6Z"/>
        <path d="M10.4,17.6a2,2,0,0,0-2.8,2.8l15,15a2,2,0,0,0,2.8-2.8Z"/>
        <path d="M5.4,22.6a1.9,1.9,0,0,0-2.8,0,1.9,1.9,0,0,0,0,2.8l7,7a2,2,0,0,0,2.8-2.8Z"/>
      </g>
    </g>
  </g>
</svg>
<script type = "text" id = "colors">
// Copyright(c) 2021 Björn Ottosson
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this softwareand associated documentation files(the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and /or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions :
// The above copyright noticeand this permission notice shall be included in all
// copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#define M_PI 3.1415926535897932384626433832795
float cbrt( float x )
{
    return sign(x)*pow(abs(x),1.0f/3.0f);
}

float srgb_transfer_function(float a)
{
    return .0031308f >= a ? 12.92f * a : 1.055f * pow(a, .4166666666666667f) - .055f;
}

float srgb_transfer_function_inv(float a)
{
    return .04045f < a ? pow((a + .055f) / 1.055f, 2.4f) : a / 12.92f;
}

vec3 linear_srgb_to_oklab(vec3 c)
{
    float l = 0.4122214708f * c.r + 0.5363325363f * c.g + 0.0514459929f * c.b;
    float m = 0.2119034982f * c.r + 0.6806995451f * c.g + 0.1073969566f * c.b;
    float s = 0.0883024619f * c.r + 0.2817188376f * c.g + 0.6299787005f * c.b;
    float l_ = cbrt(l);
    float m_ = cbrt(m);
    float s_ = cbrt(s);
    return vec3(
        0.2104542553f * l_ + 0.7936177850f * m_ - 0.0040720468f * s_,
        1.9779984951f * l_ - 2.4285922050f * m_ + 0.4505937099f * s_,
        0.0259040371f * l_ + 0.7827717662f * m_ - 0.8086757660f * s_
    );
}

vec3 oklab_to_linear_srgb(vec3 c)
{
    float l_ = c.x + 0.3963377774f * c.y + 0.2158037573f * c.z;
    float m_ = c.x - 0.1055613458f * c.y - 0.0638541728f * c.z;
    float s_ = c.x - 0.0894841775f * c.y - 1.2914855480f * c.z;
    float l = l_ * l_ * l_;
    float m = m_ * m_ * m_;
    float s = s_ * s_ * s_;
    return vec3(
        +4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s,
        -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s,
        -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s
    );
}

// Finds the maximum saturation possible for a given hue that fits in sRGB
// Saturation here is defined as S = C/L
// a and b must be normalized so a^2 + b^2 == 1
float compute_max_saturation(float a, float b)
{
    // Max saturation will be when one of r, g or b goes below zero.	// Select different coefficients depending on which component goes below zero first
    float k0, k1, k2, k3, k4, wl, wm, ws;	if (-1.88170328f * a - 0.80936493f * b > 1.f)
    {
        // Red component
        k0 = +1.19086277f; k1 = +1.76576728f; k2 = +0.59662641f; k3 = +0.75515197f; k4 = +0.56771245f;
        wl = +4.0767416621f; wm = -3.3077115913f; ws = +0.2309699292f;
    }
    else if (1.81444104f * a - 1.19445276f * b > 1.f)
    {
        // Green component
        k0 = +0.73956515f; k1 = -0.45954404f; k2 = +0.08285427f; k3 = +0.12541070f; k4 = +0.14503204f;
        wl = -1.2684380046f; wm = +2.6097574011f; ws = -0.3413193965f;
    }
    else
    {
        // Blue component
        k0 = +1.35733652f; k1 = -0.00915799f; k2 = -1.15130210f; k3 = -0.50559606f; k4 = +0.00692167f;
        wl = -0.0041960863f; wm = -0.7034186147f; ws = +1.7076147010f;
    }
    
    // Approximate max saturation using a polynomial:
    float S = k0 + k1 * a + k2 * b + k3 * a * a + k4 * a * b;	// Do one step Halley's method to get closer
    // this gives an error less than 10e6, except for some blue hues where the dS/dh is close to infinite
    // this should be sufficient for most applications, otherwise do two/three steps
    float k_l = +0.3963377774f * a + 0.2158037573f * b;
    float k_m = -0.1055613458f * a - 0.0638541728f * b;
    float k_s = -0.0894841775f * a - 1.2914855480f * b;	{
        float l_ = 1.f + S * k_l;
        float m_ = 1.f + S * k_m;
        float s_ = 1.f + S * k_s;
        float l = l_ * l_ * l_;
        float m = m_ * m_ * m_;
        float s = s_ * s_ * s_;
        float l_dS = 3.f * k_l * l_ * l_;
        float m_dS = 3.f * k_m * m_ * m_;
        float s_dS = 3.f * k_s * s_ * s_;
        float l_dS2 = 6.f * k_l * k_l * l_;
        float m_dS2 = 6.f * k_m * k_m * m_;
        float s_dS2 = 6.f * k_s * k_s * s_;
        float f = wl * l + wm * m + ws * s;
        float f1 = wl * l_dS + wm * m_dS + ws * s_dS;
        float f2 = wl * l_dS2 + wm * m_dS2 + ws * s_dS2;
        S = S - f * f1 / (f1 * f1 - 0.5f * f * f2);
    }	return S;
}

// finds L_cusp and C_cusp for a given hue
// a and b must be normalized so a^2 + b^2 == 1
vec2 find_cusp(float a, float b)
{
    // First, find the maximum saturation (saturation S = C/L)
    float S_cusp = compute_max_saturation(a, b);	// Convert to linear sRGB to find the first point where at least one of r,g or b >= 1:
    vec3 rgb_at_max = oklab_to_linear_srgb(vec3( 1, S_cusp * a, S_cusp * b ));
    float L_cusp = cbrt(1.f / max(max(rgb_at_max.r, rgb_at_max.g), rgb_at_max.b));
    float C_cusp = L_cusp * S_cusp;	return vec2( L_cusp , C_cusp );
}

// Finds intersection of the line defined by 
// L = L0 * (1 - t) + t * L1;
// C = t * C1;
// a and b must be normalized so a^2 + b^2 == 1
float find_gamut_intersection(float a, float b, float L1, float C1, float L0, vec2 cusp)
{
    // Find the intersection for upper and lower half seprately
    float t;
    if (((L1 - L0) * cusp.y - (cusp.x - L0) * C1) <= 0.f)
    {
        // Lower half	
        t = cusp.y * L0 / (C1 * cusp.x + cusp.y * (L0 - L1));
    }
    else
    {
        // Upper half		// First intersect with triangle
        t = cusp.y * (L0 - 1.f) / (C1 * (cusp.x - 1.f) + cusp.y * (L0 - L1));		// Then one step Halley's method
        {
            float dL = L1 - L0;
            float dC = C1;
            float k_l = +0.3963377774f * a + 0.2158037573f * b;
            float k_m = -0.1055613458f * a - 0.0638541728f * b;
            float k_s = -0.0894841775f * a - 1.2914855480f * b;
            float l_dt = dL + dC * k_l;
            float m_dt = dL + dC * k_m;
            float s_dt = dL + dC * k_s;
            // If higher accuracy is required, 2 or 3 iterations of the following block can be used:
            {
                float L = L0 * (1.f - t) + t * L1;
                float C = t * C1;
                float l_ = L + C * k_l;
                float m_ = L + C * k_m;
                float s_ = L + C * k_s;
                float l = l_ * l_ * l_;
                float m = m_ * m_ * m_;
                float s = s_ * s_ * s_;
                float ldt = 3.f * l_dt * l_ * l_;
                float mdt = 3.f * m_dt * m_ * m_;
                float sdt = 3.f * s_dt * s_ * s_;
                float ldt2 = 6.f * l_dt * l_dt * l_;
                float mdt2 = 6.f * m_dt * m_dt * m_;
                float sdt2 = 6.f * s_dt * s_dt * s_;
                float r = 4.0767416621f * l - 3.3077115913f * m + 0.2309699292f * s - 1.f;
                float r1 = 4.0767416621f * ldt - 3.3077115913f * mdt + 0.2309699292f * sdt;
                float r2 = 4.0767416621f * ldt2 - 3.3077115913f * mdt2 + 0.2309699292f * sdt2;
                float u_r = r1 / (r1 * r1 - 0.5f * r * r2);
                float t_r = -r * u_r;
                float g = -1.2684380046f * l + 2.6097574011f * m - 0.3413193965f * s - 1.f;
                float g1 = -1.2684380046f * ldt + 2.6097574011f * mdt - 0.3413193965f * sdt;
                float g2 = -1.2684380046f * ldt2 + 2.6097574011f * mdt2 - 0.3413193965f * sdt2;
                float u_g = g1 / (g1 * g1 - 0.5f * g * g2);
                float t_g = -g * u_g;
                float b = -0.0041960863f * l - 0.7034186147f * m + 1.7076147010f * s - 1.f;
                float b1 = -0.0041960863f * ldt - 0.7034186147f * mdt + 1.7076147010f * sdt;
                float b2 = -0.0041960863f * ldt2 - 0.7034186147f * mdt2 + 1.7076147010f * sdt2;
                float u_b = b1 / (b1 * b1 - 0.5f * b * b2);
                float t_b = -b * u_b;
                t_r = u_r >= 0.f ? t_r : 10000.f;
                t_g = u_g >= 0.f ? t_g : 10000.f;
                t_b = u_b >= 0.f ? t_b : 10000.f;
                t += min(t_r, min(t_g, t_b));
            }
        }
    }	return t;
}

float find_gamut_intersection(float a, float b, float L1, float C1, float L0)
{
    // Find the cusp of the gamut triangle
    vec2 cusp = find_cusp(a, b);
    return find_gamut_intersection(a, b, L1, C1, L0, cusp);
}

vec3 gamut_clip_preserve_chroma(vec3 rgb)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float L0 = clamp(L, 0.f, 1.f);	float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;
    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_project_to_0_5(vec3 rgb)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float L0 = 0.5;	float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;
    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_project_to_L_cusp(vec3 rgb)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
    vec2 cusp = find_cusp(a_, b_);	float L0 = cusp.x;	float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;
    return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_adaptive_L0_0_5(vec3 rgb, float alpha)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);
    float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float Ld = L - 0.5f;
    float e1 = 0.5f + abs(Ld) + alpha * C;
    float L0 = 0.5f * (1.f + sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * abs(Ld))));
    float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

vec3 gamut_clip_adaptive_L0_L_cusp(vec3 rgb, float alpha)
{
    if (rgb.r < 1.f && rgb.g < 1.f && rgb.b < 1.f && rgb.r > 0.f && rgb.g > 0.f && rgb.b > 0.f)
        return rgb;	vec3 lab = linear_srgb_to_oklab(rgb);	float L = lab.x;
    float eps = 0.00001f;
    float C = max(eps, sqrt(lab.y * lab.y + lab.z * lab.z));
    float a_ = lab.y / C;
    float b_ = lab.z / C;	// The cusp is computed here and in find_gamut_intersection, an optimized solution would only compute it once.
    vec2 cusp = find_cusp(a_, b_);	float Ld = L - cusp.x;
    float k = 2.f * (Ld > 0.f ? 1.f - cusp.x : cusp.x);	float e1 = 0.5f * k + abs(Ld) + alpha * C / k;
    float L0 = cusp.x + 0.5f * (sign(Ld) * (e1 - sqrt(e1 * e1 - 2.f * k * abs(Ld))));
    float t = find_gamut_intersection(a_, b_, L, C, L0);
    float L_clipped = L0 * (1.f - t) + t * L;
    float C_clipped = t * C;	return oklab_to_linear_srgb(vec3( L_clipped, C_clipped * a_, C_clipped * b_ ));
}

float toe(float x)
{
    float k_1 = 0.206f;
    float k_2 = 0.03f;
    float k_3 = (1.f + k_1) / (1.f + k_2);
    return 0.5f * (k_3 * x - k_1 + sqrt((k_3 * x - k_1) * (k_3 * x - k_1) + 4.f * k_2 * k_3 * x));
}

float toe_inv(float x)
{
    float k_1 = 0.206f;
    float k_2 = 0.03f;
    float k_3 = (1.f + k_1) / (1.f + k_2);
    return (x * x + k_1 * x) / (k_3 * (x + k_2));
}

vec2 to_ST(vec2 cusp)
{
    float L = cusp.x;
    float C = cusp.y;
    return vec2( C / L, C / (1.f - L) );
}

// Returns a smooth approximation of the location of the cusp
// This polynomial was created by an optimization process
// It has been designed so that S_mid < S_max and T_mid < T_max

vec2 get_ST_mid(float a_, float b_)
{
    float S = 0.11516993f + 1.f / (
        +7.44778970f + 4.15901240f * b_
        + a_ * (-2.19557347f + 1.75198401f * b_
            + a_ * (-2.13704948f - 10.02301043f * b_
                + a_ * (-4.24894561f + 5.38770819f * b_ + 4.69891013f * a_
                    )))
        );
        float T = 0.11239642f + 1.f / (
            +1.61320320f - 0.68124379f * b_
            + a_ * (+0.40370612f + 0.90148123f * b_
                + a_ * (-0.27087943f + 0.61223990f * b_
                    + a_ * (+0.00299215f - 0.45399568f * b_ - 0.14661872f * a_
                    )))
     );	return vec2( S, T );
}

vec3 get_Cs(float L, float a_, float b_)
    {
    vec2 cusp = find_cusp(a_, b_);	float C_max = find_gamut_intersection(a_, b_, L, 1.f, L, cusp);
    vec2 ST_max = to_ST(cusp);
    // Scale factor to compensate for the curved part of gamut shape:
    float k = C_max / min((L * ST_max.x), (1.f - L) * ST_max.y);
    float C_mid;
    {
        vec2 ST_mid = get_ST_mid(a_, b_);		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        float C_a = L * ST_mid.x;
        float C_b = (1.f - L) * ST_mid.y;
        C_mid = 0.9f * k * sqrt(sqrt(1.f / (1.f / (C_a * C_a * C_a * C_a) + 1.f / (C_b * C_b * C_b * C_b))));
    }
    float C_0;
    {
     // for C_0, the shape is independent of hue, so vec2 are constant. Values picked to roughly be the average values of vec2.
        float C_a = L * 0.4f;
        float C_b = (1.f - L) * 0.8f;		// Use a soft minimum function, instead of a sharp triangle shape to get a smooth value for chroma.
        C_0 = sqrt(1.f / (1.f / (C_a * C_a) + 1.f / (C_b * C_b)));
    }	return vec3( C_0, C_mid, C_max );
}

vec3 okhsl_to_srgb(vec3 hsl)
{
    float h = hsl.x;
    float s = hsl.y;
    float l = hsl.z;
    if (l == 1.0f)
    {
        return vec3( 1.f, 1.f, 1.f );
    }
    else if (l == 0.f)
    {
        return vec3( 0.f, 0.f, 0.f );
    }
 	float a_ = cos(2.f * M_PI * h);
    float b_ = sin(2.f * M_PI * h);
    float L = toe_inv(l);
    vec3 cs = get_Cs(L, a_, b_);
    float C_0 = cs.x;
    float C_mid = cs.y;
    float C_max = cs.z;
    float mid = 0.8f;
    float mid_inv = 1.25f;	float C, t, k_0, k_1, k_2;
    if (s < mid)
    {
        t = mid_inv * s;
        k_1 = mid * C_0;
        k_2 = (1.f - k_1 / C_mid);
        C = t * k_1 / (1.f - k_2 * t);
    }
    else
    {
        t = (s - mid)/ (1.f - mid);
        k_0 = C_mid;
        k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
        k_2 = (1.f - (k_1) / (C_max - C_mid));
        C = k_0 + t * k_1 / (1.f - k_2 * t);
    }
 
    vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));
    return vec3(
        srgb_transfer_function(rgb.r),
        srgb_transfer_function(rgb.g),
        srgb_transfer_function(rgb.b)
    );
}

vec3 srgb_to_okhsl(vec3 rgb)
{
    vec3 lab = linear_srgb_to_oklab(vec3(
        srgb_transfer_function_inv(rgb.r),
        srgb_transfer_function_inv(rgb.g),
        srgb_transfer_function_inv(rgb.b)
    ));
    float C = sqrt(lab.y * lab.y + lab.z * lab.z);
    float a_ = lab.y / C;
    float b_ = lab.z / C;
    float L = lab.x;
    float h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;
    vec3 cs = get_Cs(L, a_, b_);
    float C_0 = cs.x;
    float C_mid = cs.y;
    float C_max = cs.z;	// Inverse of the interpolation in okhsl_to_srgb:
    float mid = 0.8f;
    float mid_inv = 1.25f;	float s;
    if (C < C_mid)
    {
        float k_1 = mid * C_0;
        float k_2 = (1.f - k_1 / C_mid);
        float t = C / (k_1 + k_2 * C);
        s = t * mid;
    }
    else
    {
        float k_0 = C_mid;
        float k_1 = (1.f - mid) * C_mid * C_mid * mid_inv * mid_inv / C_0;
        float k_2 = (1.f - (k_1) / (C_max - C_mid));
        float t = (C - k_0) / (k_1 + k_2 * (C - k_0));
        s = mid + (1.f - mid) * t;
    }
    float l = toe(L);
    return vec3( h, s, l );
}

vec3 okhsv_to_srgb(vec3 hsv)
{
    float h = hsv.x;
    float s = hsv.y;
    float v = hsv.z;
    float a_ = cos(2.f * M_PI * h);
    float b_ = sin(2.f * M_PI * h);
    vec2 cusp = find_cusp(a_, b_);
    vec2 ST_max = to_ST(cusp);
    float S_max = ST_max.x;
    float T_max = ST_max.y;
    float S_0 = 0.5f;
    float k = 1.f- S_0 / S_max;	// first we compute L and V as if the gamut is a perfect triangle:	// L, C when v==1:
    float L_v = 1.f   - s * S_0 / (S_0 + T_max - T_max * k * s);
    float C_v = s * T_max * S_0 / (S_0 + T_max - T_max * k * s);
    float L = v * L_v;
    float C = v * C_v;	// then we compensate for both toe and the curved top part of the triangle:
    float L_vt = toe_inv(L_v);
    float C_vt = C_v * L_vt / L_v;	float L_new = toe_inv(L);
    C = C * L_new / L;
    L = L_new;	vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));
    float scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));
    L = L * scale_L;
    C = C * scale_L;	vec3 rgb = oklab_to_linear_srgb(vec3( L, C * a_, C * b_ ));
    return vec3(
        srgb_transfer_function(rgb.r),
        srgb_transfer_function(rgb.g),
        srgb_transfer_function(rgb.b)
    );
}

vec3 srgb_to_okhsv(vec3 rgb)
{
    vec3 lab = linear_srgb_to_oklab(vec3(
        srgb_transfer_function_inv(rgb.r),
        srgb_transfer_function_inv(rgb.g),
        srgb_transfer_function_inv(rgb.b)
    ));
    float C = sqrt(lab.y * lab.y + lab.z * lab.z);
    float a_ = lab.y / C;
    float b_ = lab.z / C;	float L = lab.x;
    float h = 0.5f + 0.5f * atan(-lab.z, -lab.y) / M_PI;
    vec2 cusp = find_cusp(a_, b_);
    vec2 ST_max = to_ST(cusp);
    float S_max = ST_max.x;
    float T_max = ST_max.y;
    float S_0 = 0.5f;
    float k = 1.f - S_0 / S_max;	// first we find L_v, C_v, L_vt and C_vt
    float t = T_max / (C + L * T_max);
    float L_v = t * L;
    float C_v = t * C;	float L_vt = toe_inv(L_v);
    float C_vt = C_v * L_vt / L_v;	// we can then use these to invert the step that compensates for the toe and the curved top part of the triangle:
    vec3 rgb_scale = oklab_to_linear_srgb(vec3( L_vt, a_ * C_vt, b_ * C_vt ));
    float scale_L = cbrt(1.f / max(max(rgb_scale.r, rgb_scale.g), max(rgb_scale.b, 0.f)));
    L = L / scale_L;
    C = C / scale_L;
    C = C * toe(L) / L;
    L = toe(L);	// we can now compute v and s:
    float v = L / L_v;
    float s = (S_0 + T_max) * C_v / ((T_max * S_0) + T_max * k * C_v);	return vec3 (h, s, v );
}

vec3 srgb_to_oklab(vec3 rgb) {
    return linear_srgb_to_oklab(vec3(
        srgb_transfer_function_inv(rgb.r),
        srgb_transfer_function_inv(rgb.g),
        srgb_transfer_function_inv(rgb.b)
    ));
}

vec3 hsl2rgb( in vec3 c )
{
    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );
    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));
}

vec3 rgb2hsl( in vec3 c ){
float h = 0.0;
    float s = 0.0;
    float l = 0.0;
    float r = c.r;
    float g = c.g;
    float b = c.b;
    float cMin = min( r, min( g, b ) );
    float cMax = max( r, max( g, b ) );	l = ( cMax + cMin ) / 2.0;
    if ( cMax > cMin ) {
        float cDelta = cMax - cMin;
        //s = l < .05 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) ); Original
        s = l < .0 ? cDelta / ( cMax + cMin ) : cDelta / ( 2.0 - ( cMax + cMin ) );
        if ( r == cMax ) {
            h = ( g - b ) / cDelta;
        } else if ( g == cMax ) {
            h = 2.0 + ( b - r ) / cDelta;
        } else {
            h = 4.0 + ( r - g ) / cDelta;
        }		if ( h < 0.0) {
            h += 6.0;
        }
        h = h / 6.0;
    }
    return vec3( h, s, l );
}

bool inDither( float h, float antiHue, float antiRad) {
    return (((h > antiHue - antiRad) && (h < antiHue + antiRad))) ||
    (((h - 1.0f > antiHue - antiRad) && (h - 1.0f < antiHue + antiRad))) ||
    (((1.0f + h > antiHue - antiRad) && (1.0f + h < antiHue + antiRad)));
}

float dither( float h, float r, float antiHue, float antiRad) {
    float rightBound = antiHue - antiRad;
    if (rightBound < -0.5f) rightBound = rightBound + 1.0f;
    float leftBound = antiHue + antiRad;
    if (leftBound > 0.5f) leftBound = leftBound - 1.0f;
    if ((h > antiHue - antiRad) && (h < antiHue + antiRad))
        if (((h - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
            h = rightBound;
        else h = leftBound;
    else if ((h - 1.0f > antiHue - antiRad) && (h - 1.0f < antiHue + antiRad))
        if (((h - 1.0f - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
         h = rightBound;
        else h = leftBound;
    else if ((1.0f + h > antiHue - antiRad) && (1.0f + h < antiHue + antiRad))
        if (((1.0f + h - (antiHue - antiRad)) / (2.0f * antiRad)) < r)
            h = rightBound;
        else h = leftBound;
    return h;
}

vec3 hsv2rgb(vec3 c)
{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}

//const vec3 wref =  vec3(.950456, 1.0, 1.089058); 
const vec3 wref =  vec3(1.0, 1.0, 1.0);

float xyzR(float t){ return mix(t*t*t , 0.1284185*(t - 0.139731), step(t,0.20689655)); }

vec3 lch2rgb(in vec3 c)
{
    c = vec3(c.x, cos(c.z) * c.y, sin(c.z) * c.y);
    float lg = 1./116.*(c.x + 16.);
    vec3 xyz = vec3(wref.x*xyzR(lg + 0.002*c.y),
    				wref.y*xyzR(lg),
    				wref.z*xyzR(lg - 0.005*c.z));
    vec3 rgb = xyz*mat3( 3.2406, -1.5372,-0.4986,
          		        -0.9689,  1.8758, 0.0415,
                	     0.0557,  -0.2040, 1.0570);
    return rgb;
}

vec3 hsluv_intersectLineLine(vec3 line1x, vec3 line1y, vec3 line2x, vec3 line2y) {
    return (line1y - line2y) / (line2x - line1x);
}

vec3 hsluv_distanceFromPole(vec3 pointx,vec3 pointy) {
    return sqrt(pointx*pointx + pointy*pointy);
}

vec3 hsluv_lengthOfRayUntilIntersect(float theta, vec3 x, vec3 y) {
    vec3 len = y / (sin(theta) - x * cos(theta));
    if (len.r < 0.0) {len.r=1000.0;}
    if (len.g < 0.0) {len.g=1000.0;}
    if (len.b < 0.0) {len.b=1000.0;}
    return len;
}

float hsluv_maxSafeChromaForL(float L){
    mat3 m2 = mat3(
         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,
        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,
        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  
    );
    float sub0 = L + 16.0;
    float sub1 = sub0 * sub0 * sub0 * .000000641;
    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;
    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;
    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;
    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;
    vec3 bounds0x = top1 / bottom;
    vec3 bounds0y = top2 / bottom;
    vec3 bounds1x =              top1 / (bottom+126452.0);
    vec3 bounds1y = (top2-769860.0*L) / (bottom+126452.0);
    vec3 xs0 = hsluv_intersectLineLine(bounds0x, bounds0y, -1.0/bounds0x, vec3(0.0) );
    vec3 xs1 = hsluv_intersectLineLine(bounds1x, bounds1y, -1.0/bounds1x, vec3(0.0) );
    vec3 lengths0 = hsluv_distanceFromPole( xs0, bounds0y + xs0 * bounds0x );
    vec3 lengths1 = hsluv_distanceFromPole( xs1, bounds1y + xs1 * bounds1x );
    return  min(lengths0.r,
            min(lengths1.r,
            min(lengths0.g,
            min(lengths1.g,
            min(lengths0.b,
                lengths1.b)))));
}

float hsluv_maxChromaForLH(float L, float H) {
    float hrad = radians(H);
    mat3 m2 = mat3(
         3.2409699419045214  ,-0.96924363628087983 , 0.055630079696993609,
        -1.5373831775700935  , 1.8759675015077207  ,-0.20397695888897657 ,
        -0.49861076029300328 , 0.041555057407175613, 1.0569715142428786  
    );
    float sub1 = pow(L + 16.0, 3.0) / 1560896.0;
    float sub2 = sub1 > 0.0088564516790356308 ? sub1 : L / 903.2962962962963;
    vec3 top1   = (284517.0 * m2[0] - 94839.0  * m2[2]) * sub2;
    vec3 bottom = (632260.0 * m2[2] - 126452.0 * m2[1]) * sub2;
    vec3 top2   = (838422.0 * m2[2] + 769860.0 * m2[1] + 731718.0 * m2[0]) * L * sub2;
    vec3 bound0x = top1 / bottom;
    vec3 bound0y = top2 / bottom;
    vec3 bound1x =              top1 / (bottom+126452.0);
    vec3 bound1y = (top2-769860.0*L) / (bottom+126452.0);
    vec3 lengths0 = hsluv_lengthOfRayUntilIntersect(hrad, bound0x, bound0y );
    vec3 lengths1 = hsluv_lengthOfRayUntilIntersect(hrad, bound1x, bound1y );
    return  min(lengths0.r,
            min(lengths1.r,
            min(lengths0.g,
            min(lengths1.g,
            min(lengths0.b,
                lengths1.b)))));
}

float hsluv_fromLinear(float c) {
    return c <= 0.0031308 ? 12.92 * c : 1.055 * pow(c, 1.0 / 2.4) - 0.055;
}

vec3 hsluv_fromLinear(vec3 c) {
    return vec3( hsluv_fromLinear(c.r), hsluv_fromLinear(c.g), hsluv_fromLinear(c.b) );
}

float hsluv_toLinear(float c) {
    return c > 0.04045 ? pow((c + 0.055) / (1.0 + 0.055), 2.4) : c / 12.92;
}

vec3 hsluv_toLinear(vec3 c) {
    return vec3( hsluv_toLinear(c.r), hsluv_toLinear(c.g), hsluv_toLinear(c.b) );
}

float hsluv_yToL(float Y){
    return Y <= 0.0088564516790356308 ? Y * 903.2962962962963 : 116.0 * pow(Y, 1.0 / 3.0) - 16.0;
}

float hsluv_lToY(float L) {
    return L <= 8.0 ? L / 903.2962962962963 : pow((L + 16.0) / 116.0, 3.0);
}

vec3 xyzToRgb(vec3 tuple) {
    const mat3 m = mat3( 
        3.2409699419045214  ,-1.5373831775700935 ,-0.49861076029300328 ,
       -0.96924363628087983 , 1.8759675015077207 , 0.041555057407175613,
        0.055630079696993609,-0.20397695888897657, 1.0569715142428786  );
    return hsluv_fromLinear(tuple*m);
}

vec3 rgbToXyz(vec3 tuple) {
    const mat3 m = mat3(
        0.41239079926595948 , 0.35758433938387796, 0.18048078840183429 ,
        0.21263900587151036 , 0.71516867876775593, 0.072192315360733715,
        0.019330818715591851, 0.11919477979462599, 0.95053215224966058 
    );
    return hsluv_toLinear(tuple) * m;
}

vec3 xyzToLuv(vec3 tuple){
    float X = tuple.x;
    float Y = tuple.y;
    float Z = tuple.z;
    float L = hsluv_yToL(Y);
    float div = 1./dot(tuple,vec3(1,15,3)); 
    return vec3(
        1.,
        (52. * (X*div) - 2.57179),
        (117.* (Y*div) - 6.08816)
    ) * L;
}

vec3 luvToXyz(vec3 tuple) {
    float L = tuple.x;
    float U = tuple.y / (13.0 * L) + 0.19783000664283681;
    float V = tuple.z / (13.0 * L) + 0.468319994938791;
    float Y = hsluv_lToY(L);
    float X = 2.25 * U * Y / V;
    float Z = (3./V - 5.)*Y - (X/3.);
    return vec3(X, Y, Z);
}

vec3 luvToLch(vec3 tuple) {
    float L = tuple.x;
    float U = tuple.y;
    float V = tuple.z;
    float C = length(tuple.yz);
    float H = degrees(atan(V,U));
    if (H < 0.0) {
        H = 360.0 + H;
    }
    return vec3(L, C, H);
}

vec3 lchToLuv(vec3 tuple) {
    float hrad = radians(tuple.b);
    return vec3(
        tuple.r,
        cos(hrad) * tuple.g,
        sin(hrad) * tuple.g
    );
}

vec3 hsluvToLch(vec3 tuple) {
    tuple.g *= hsluv_maxChromaForLH(tuple.b, tuple.r) * .01;
    return tuple.bgr;
}

vec3 lchToHsluv(vec3 tuple) {
    tuple.g /= hsluv_maxChromaForLH(tuple.r, tuple.b) * .01;
    return tuple.bgr;
}

vec3 hpluvToLch(vec3 tuple) {
    tuple.g *= hsluv_maxSafeChromaForL(tuple.b) * .01;
    return tuple.bgr;
}

vec3 lchToHpluv(vec3 tuple) {
    tuple.g /= hsluv_maxSafeChromaForL(tuple.r) * .01;
    return tuple.bgr;
}

vec3 lchToRgb(vec3 tuple) {
    return xyzToRgb(luvToXyz(lchToLuv(tuple)));
}

vec3 rgbToLch(vec3 tuple) {
    return luvToLch(xyzToLuv(rgbToXyz(tuple)));
}

vec3 hsluvToRgb(vec3 tuple) {
    return lchToRgb(hsluvToLch(tuple));
}

vec3 rgbToHsluv(vec3 tuple) {
    return lchToHsluv(rgbToLch(tuple));
}

vec3 hpluvToRgb(vec3 tuple) {
    return lchToRgb(hpluvToLch(tuple));
}

vec3 rgbToHpluv(vec3 tuple) {
    return lchToHpluv(rgbToLch(tuple));
}

vec3 luvToRgb(vec3 tuple){
    return xyzToRgb(luvToXyz(tuple));
}

vec3 RGBtoXYZ(vec3 shade) {
    mat3 conversion = mat3( 0.4497288 , 0.3162486 , 0.1844926,
    0.2446525 , 0.6720283 , 0.0833192,
    0.0251848 , 0.1411824 , 0.9224628); // Apple RGB conversion matrix
    return conversion * shade;
}

vec3 sRGBtoXYZ(vec3 shade) {
    mat3 conversion = mat3( 0.4124564 , 0.3575761 , 0.1804375,
    0.2126729 , 0.7151522 , 0.0721750,
    0.0193339 , 0.1191920 , 0.9503041);
    return conversion * shade;
}

vec3 XYZtoLab(vec3 shade) {
    vec3 d65_ref = vec3(0.9504, 1.0000, 1.0888); // this reference was used for the XYZ conversion
    vec3 xyz_rat = shade / d65_ref;
    float epsilon = 0.008856;
    float kappa = 903.3;
    vec3 f = vec3(0.0,0.0,0.0);
    vec3 Lab = vec3(0.0,0.0,0.0);

    if (xyz_rat.x > epsilon) {f.x = pow(xyz_rat.x, 1.0/3.0);}
    else {f.x = (kappa * xyz_rat.x + 16.0) / 116.0;}
    if (xyz_rat.y > epsilon) {f.y = pow(xyz_rat.y, 1.0/3.0);}
    else {f.y = (kappa * xyz_rat.y + 16.0) / 116.0;}
    if (xyz_rat.z > epsilon) {f.z = pow(xyz_rat.z, 1.0/3.0);}
    else {f.z = (kappa * xyz_rat.z + 16.0) / 116.0;}

    Lab.y = 116.0 * f.y - 16.0;
    Lab.x = -500.0 * (f.x - f.y);
    Lab.z = -200.0 * (f.y - f.z);

    Lab = Lab / 100.0;

    return Lab;
}

vec3 RGBtoLab(vec3 shade) {
    return XYZtoLab(RGBtoXYZ(shade));
}

vec3 sRGBtoLab(vec3 shade) {
    return XYZtoLab(sRGBtoXYZ(shade));
}

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

vec3 RGB2Lab(vec3 rgb){
    float R = rgb.x;
    float G = rgb.y;
    float B = rgb.z;
    // threshold
    float T = 0.008856;

    float X = R * 0.412453 + G * 0.357580 + B * 0.180423;
    float Y = R * 0.212671 + G * 0.715160 + B * 0.072169;
    float Z = R * 0.019334 + G * 0.119193 + B * 0.950227;

    // Normalize for D65 white point
    X = X / 0.950456;
    Y = Y;
    Z = Z / 1.088754;

    bool XT, YT, ZT;
    XT = false; YT=false; ZT=false;
    if(X > T) XT = true;
    if(Y > T) YT = true;
    if(Z > T) ZT = true;

    float Y3 = pow(Y,1.0/3.0);
    float fX, fY, fZ;
    if(XT){ fX = pow(X, 1.0/3.0);} else{ fX = 7.787 * X + 16.0/116.0; }
    if(YT){ fY = Y3; } else{ fY = 7.787 * Y + 16.0/116.0 ; }
    if(ZT){ fZ = pow(Z,1.0/3.0); } else{ fZ = 7.787 * Z + 16.0/116.0; }

    float L; if(YT){ L = (116.0 * Y3) - 16.0; }else { L = 903.3 * Y; }
    float a = 500.0 * ( fX - fY );
    float b = 200.0 * ( fY - fZ );

    return vec3(L,a,b) / 100.;
}




// from https://www.shadertoy.com/view/wdVyWc

#define diag3(v) mat3((v).x, 0.0, 0.0, 0.0, (v).y, 0.0, 0.0, 0.0, (v).z)
#define xy_to_XYZ(x, y) vec3(x/y, 1.0, (1.0 - x - y)/y)

const vec3 D65 = xy_to_XYZ(0.31271, 0.32902);
const mat3 sRGB = mat3(xy_to_XYZ(0.64, 0.33), xy_to_XYZ(0.30, 0.60), xy_to_XYZ(0.15, 0.06));
const mat3 sRGB_TO_XYZ_D65 = sRGB*diag3(inverse(sRGB)*D65);
const mat3 XYZ_D65_TO_sRGB = inverse(sRGB_TO_XYZ_D65);

vec3 sRGB_OETF(vec3 c) {
    vec3 a = 12.92*c;
    vec3 b = 1.055*pow(c, vec3(1.0/2.4)) - 0.055;
    return mix(a, b, greaterThan(c, vec3(0.00313066844250063)));
}

vec3 sRGB_EOTF(vec3 c) {
    vec3 a = c/12.92;
    vec3 b = pow((c + 0.055)/1.055, vec3(2.4));
    return mix(a, b, greaterThan(c, vec3(0.0404482362771082)));
}

#define adapt_aux(x) pow(F_L*abs(x), vec3(0.42))
#define adapt(x) 400.0*sign(x)*adapt_aux(x)/(27.13 + adapt_aux(x))
#define unadapt(x) sign(x)/F_L*pow(27.13*abs(x)/(400.0 - abs(x)), vec3(1.0/0.42))

const mat3 M16 = mat3(
    +0.401288, -0.250268, -0.002079,
    +0.650173, +1.204414, +0.048952,
    -0.051461, +0.045854, +0.953127
);

// sRGB conditions, average surround
const vec3 XYZ_w = D65;
const float Y_w = XYZ_w.y;
const float Y_b = 0.2;
const float L_w = 64.0/radians(180.0);
const float L_A = L_w*Y_b/Y_w;
const float F = 1.0;
const float c = 0.69;
const float N_c = F;

// step 0*
const vec3 RGB_w = M16*XYZ_w;
const float D = 1.0; // clamp(F*(1.0 - 1.0/3.6*exp((-L_A - 42.0)/92.0)), 0.0, 1.0);
const vec3 D_RGB = D*(Y_w/RGB_w) + 1.0 - D;
const float k4 = pow(1.0/(5.0*L_A + 1.0), 4.0);
const float F_L = k4*L_A + 0.1*pow(1.0 - k4, 2.0)*pow(5.0*L_A, 1.0/3.0);
const float n = Y_b/Y_w;
const float z = 1.48 + sqrt(n);
const float N_bb = 0.725/pow(n, 0.2);
const float N_cb = N_bb;
const vec3 RGB_cw = D_RGB*RGB_w;
const vec3 RGB_aw = adapt(RGB_cw);
const float A_w = dot(vec3(2.0, 1.0, 0.05), RGB_aw)*N_bb;

vec3 XYZ_D65_to_CAM16(vec3 XYZ) {
    // step 1
    vec3 RGB = M16*XYZ;
    // step 2
    vec3 RGB_c = D_RGB*RGB;
    // step 3*
    vec3 RGB_a = adapt(RGB_c);
    // step 4*
    const mat3x4 m = 1.0/1980.0*mat3x4(
        3960.0, 1980.0, 220.0, 1980.0,
        1980.0, -2160.0, 220.0, 1980.0,
        99.0, 180.0, -440.0, 2079.0
    );
    vec4 aux = m*RGB_a; // p_2, a, b, u
    float h = atan(aux.z, aux.y);
    // step 5
    float e_t = 0.25*(cos(h + 2.0) + 3.8);
    // step 6*
    float A = aux.x*N_bb;
    // step 7
    float J = pow(A/A_w, c*z);
    // step 8
    // step 9*
    float t = 5e4/13.0*N_c*N_cb*e_t*length(aux.yz)/(aux.w + 0.305);
    float alpha = pow(t, 0.9)*pow(1.64 - pow(0.29, n), 0.73);
    float C = 0.01*alpha*sqrt(J);
    float M = C*pow(F_L, 0.25);
    return vec3(J, M, h);
}

vec3 CAM16_to_XYZ_D65(vec3 JMh) {
    // step 1
    // step 1-1
    // step 1-2*
    float C = JMh.y/pow(F_L, 0.25);
    float alpha = JMh.x == 0.0 ? JMh.x : 100.0*C/sqrt(JMh.x);
    float t = pow(alpha/pow(1.64 - pow(0.29, n), 0.73), 1.0/0.9);
    // step 1-3
    // step 2*
    float e_t = 0.25*(cos(JMh.z + 2.0) + 3.8);
    float A = A_w*pow(JMh.x, 1.0/(c*z));
    float p_1 = 5e4/13.0*N_c*N_cb*e_t;
    float p_2 = A/N_bb;
    // step 3*
    vec2 cs = vec2(cos(JMh.z), sin(JMh.z));
    float r = 23.0*(p_2 + 0.305)*t/(23.0*p_1 + t*dot(vec2(11.0, 108.0), cs));
    vec2 ab = r*cs;
    // step 4
    const mat3 m = 1.0/1403.0*mat3(
        460.0, 460.0, 460.0,
        451.0, -891.0, -220.0,
        288.0, -261.0, -6300.0
    );
    vec3 RGB_a = m*vec3(p_2, ab);
    // step 5*
    vec3 RGB_c = unadapt(RGB_a);
    // step 6
    vec3 RGB = RGB_c/D_RGB;
    // step 7
    return inverse(M16)*RGB;
}

vec3 XYZ_D65_to_CAM16_UCS(vec3 XYZ) {
    vec3 JMh = XYZ_D65_to_CAM16(XYZ);
    float J = 1.7*JMh.x/(1.0 + 0.7*JMh.x);
    float M = log(1.0 + 2.28*JMh.y)/2.28;
    return vec3(J, M, JMh.z);
}

vec3 CAM16_UCS_to_XYZ_D65(vec3 JMh) {
    float J = JMh.x/(1.0 - 0.7*(JMh.x - 1.0));
    float M = (exp(2.28*JMh.y) - 1.0)/2.28;
    return CAM16_to_XYZ_D65(vec3(J, M, JMh.z));
}

vec3 polar_to_standard(vec3 shade){
    return vec3(shade.x, shade.y * vec2(cos(shade.z), sin(shade.z)));
}





// from https://dev.to/ndesmic/exploring-color-math-through-color-blindness-2m2h

mat3 identity = mat3(
  1 , 0, 0,
  0 , 1 , 0 ,
  0 , 0 , 1);

mat3 protanopia = mat3(
    0.170556992,0.829443014,0.,
    0.170556991,0.829443008,0.,
    -0.004517144,0.004517144, 1.);

mat3 deuteranopia = mat3(
    0.33066007,0.66933993,0.,
    0.33066007,0.66933993,0.,
    -0.02785538,0.02785538, 1.);

mat3 tritanopia = mat3(
    1.,0.1273989,-0.1273989,
    0.,0.8739093,0.1260907,
    0.,0.8739093,0.1260907);

mat3 achromatopsia = mat3(
    .2126,0.7152,0.0722,
    .2126,0.7152,0.0722,
    .2126,0.7152,0.0722);

mat3 rotateX(float theta) {
    return mat3(
        1.0, 0., 0.,
        0., cos(theta), -sin(theta),
        0., sin(theta), cos(theta)
    );
}

mat3 rotateY(float theta) {
    return mat3(
        cos(theta), 0., sin(theta),
        0., 1., 0.,
        -sin(theta), 0., cos(theta)
    );
}

mat3 rotateZ(float theta) {
    return mat3(
        cos(theta), -sin(theta), 0.,
        sin(theta), cos(theta), 0.,
        0., 0., 1.
    );
}
</script>
<script type="x-shader/x-vertex" id="RGBVertexShader">
    varying vec3 color;
    varying float alpha;
    uniform float pointSize;
    uniform vec3 ideal;
    uniform float focus;
    uniform float time;
    uniform float severity;
    uniform bool isolate;
    uniform bool truecloud;
    uniform bool order;
    uniform bool edge;
    uniform int mode;
    uniform int type;
    uniform bool compact;
    uniform float theta1;
    uniform float theta2;
    uniform float theta3;
    uniform bool orientationLock;
    uniform float orientation;

    vec3 blindness_transform(vec3 shade) {

        mat3 transform = mat3(0.);
        vec3 color = vec3(0.0);
        if (type != 5) {
            if (type == 1) transform = protanopia;
            else if (type == 2) transform = deuteranopia;
            else if (type == 3) transform = tritanopia;
            else if (type == 4) transform = achromatopsia;
            color = vec3(
                srgb_transfer_function_inv(shade.x),
                srgb_transfer_function_inv(shade.y),
                srgb_transfer_function_inv(shade.z)) * (transform * severity + identity * (1. - severity));
            return clamp(vec3(
                srgb_transfer_function(color.x),
                srgb_transfer_function(color.y),
                srgb_transfer_function(color.z)),0.0,1.0);
        }
        
        color = srgb_to_okhsl(shade);
        //vec3 destination = okhsl_to_srgb(vec3(ideal.r, color.gb));
        //vec3 newColor = srgb_to_okhsl(mix(shade, destination, severity));
        //return okhsl_to_srgb(vec3(newColor.r, color.g, newColor.b));
        //return okhsl_to_srgb(vec3(color.r, mix(1.0,color.g,1.-severity), mix(0.5,color.b,1.-severity)));
        //return clamp(okhsl_to_srgb(vec3(mix(0.5, mod(color.r - ideal.r - 0.5,1.0), 1.-severity) + ideal.r + 0.5, color.gb)),vec3(0.0),vec3(1.0));
        return okhsl_to_srgb(vec3(ideal.r, color.gb));
    }

    vec3 convert(vec3 shade) {
        vec3 conversion = vec3(0.0);
        if (mode == 0) {
            conversion = 1.5*(rotateX(0.83*M_PI)*rotateZ(0.305*M_PI)*rotateX(M_PI/4.)*shade)-vec3(1.2,.0,.0);
        }
        else if (mode == 1) {
            conversion = 1.5*(rotateX(0.38 * M_PI)*rotateZ(0.315 * M_PI)*rotateY(0.276* M_PI)*rotateX(0.4* M_PI)*sRGBtoXYZ(shade))-vec3(1.25,.0,.0);
        }
        else if (mode == 2) {
            conversion =  1.*(RGB2Lab(vec3(srgb_transfer_function_inv(shade.x),
                srgb_transfer_function_inv(shade.y),
                srgb_transfer_function_inv(shade.z)))-vec3(.5,.0,.0));
        }
        else if (mode == 3) {
            conversion = 2.8*(srgb_to_oklab(shade)-vec3(.5,.0,.0));
        }
        else if (mode == 4) {
            // this color space seems to avoid distributing colors around grays, so this is to fix that
            vec3 new_shade = shade;
            conversion = 2.5*(polar_to_standard(XYZ_D65_to_CAM16_UCS(sRGB_TO_XYZ_D65*vec3(
                srgb_transfer_function_inv(new_shade.x),
                srgb_transfer_function_inv(new_shade.y),
                srgb_transfer_function_inv(new_shade.z))))-vec3(.5,.0,.0));
        }
        if (orientationLock) return conversion * rotateX((-ideal.r - orientation + 0.25) * 2.*M_PI);
        return conversion * rotateX((-orientation + 0.25) * 2.*M_PI);
    }

    vec3 randomizer(vec3 starter, bool edge) {
        float r1 = rand(vec2(starter.x * 1502.13, starter.y * 232.82 + starter.z * 800.1));
        float r2 = rand(vec2(starter.y * 545.36, starter.z * 646.2 + r1 * 250.));
        float r3 = rand(vec2(starter.x * 1408.33, starter.z * 257.9 + r2 * 630.));

        float speed = 1./500.;

        float p1 = ((0.5 + 1.5 * r1) * sin((0.5 + 1.5 * r2) * time * speed + 150.*rand(vec2(starter.x * 100.2 + 50. * r1, starter.y * 17.6))) / 2. + 1.0) / 2.;
        float p2 = ((0.5 + 1.5 * r2) * sin((0.5 + 1.5 * r3) * time * speed + 276.*rand(vec2(starter.y * 256.4 + 67.8 * r2, starter.z * 179.5))) / 2. + 1.0) / 2.;
        float p3 = ((0.5 + 1.5 * r3) * sin((0.5 + 1.5 * r1) * time * speed + 2039.*rand(vec2(starter.z * 98.3 + 98. * r3, starter.x * 290.5))) / 2. + 1.0) / 2.;

        if (edge) {
            speed = 1./10000.;

            p1 = (2. * sin((0.5 + 1.5 * r2) * time * speed + 150.*rand(vec2(starter.x * 100.2 + 50. * r1, starter.y * 17.6))) / 2. + 1.0) / 2.;
            p2 = (2. * sin((0.5 + 1.5 * r3) * time * speed + 276.*rand(vec2(starter.y * 256.4 + 67.8 * r2, starter.z * 179.5))) / 2. + 1.0) / 2.;
            p3 = (2. * sin((0.5 + 1.5 * r1) * time * speed + 2039.*rand(vec2(starter.z * 98.3 + 98. * r3, starter.x * 290.5))) / 2. + 1.0) / 2.;
        }

        return vec3(p1,p2,p3);
    }

    float stable_randomizer(vec3 starter) {
        float r1 = rand(vec2(starter.x * 1502.13, starter.y * 232.82 + starter.z * 800.1));
        float r2 = rand(vec2(starter.y * 545.36, starter.z * 646.2 + r1 * 250.));
        float r3 = rand(vec2(starter.x * 1408.33, starter.z * 257.9 + r2 * 630.));

        float p1 = rand(vec2(starter.x * 100.2 + 50. * r1, starter.y * 17.6));
        float p2 = rand(vec2(starter.y * 256.4 + 67.8 * r2, starter.z * 179.5));
        float p3 = rand(vec2(starter.z * 98.3 + 98. * r3, starter.x * 290.5));

        p1 = rand(vec2(starter.x * 100.2 + 50. * r1, starter.y * 17.6));
        p2 = rand(vec2(starter.y * 256.4 + 67.8 * r2, starter.z * 179.5));
        p3 = rand(vec2(starter.z * 98.3 + 98. * r3, starter.x * 290.5));

        return rand(vec2(89.8*p1,rand(vec2(107.9*p2,56.03*p3))));
    }

    // take a cube of points and returns the cube but with the points moving in a cloud
    vec3 placement(vec3 pos) {
        // freedom of movement for each particle
        float deviation = 1./16.;
        float r = stable_randomizer(pos);
        bool edge = false;
        if (r < 0.25) {
            deviation = 1.;
            edge = true;
        }

        // adjustment to make the grid more nicely distributed
        float distribution = 1.;
        vec3 new_pos = pos;
        if (mode == 2) distribution = 1.5;
        else if (mode == 3) distribution = 1.2;
        else if (mode == 4) {
            distribution = 1.3;
            vec3 okhsl = srgb_to_okhsl(pos);
            new_pos = clamp(okhsl_to_srgb(vec3(okhsl.x, mix(okhsl.y,pow(okhsl.y,2.),0.5+0.5*pow(okhsl.y,.5)), okhsl.z)),0.0,1.0);
        }

        if (type == 5) {
            vec3 xxx = srgb_to_okhsl(new_pos.rgb);
            new_pos = clamp(okhsl_to_srgb(vec3(xxx.r, pow(xxx.g, 2.0), xxx.b)),0.0,1.0);
        }

        // actual placement
        if (!order) return pow(new_pos.xyz * (1.0 - deviation) + (deviation / 2.) + deviation * (randomizer(new_pos, edge) - 0.5), vec3(distribution));
        else return pow(new_pos.xyz, vec3(distribution)); // multiplying new_pos by 65./64. seems very desirable, but there's something wonky with the colorblindness types
    }

    bool is_sent_to_colorblind_subspace(vec3 pos, float dim_size, int inv_prop) {
        return (int(position.x * dim_size) % inv_prop == 0) ||
            (int(position.y * dim_size) % inv_prop == 0) ||
            (int(position.z * dim_size) % inv_prop == 0);
    }

    void main() {

        // allows saturation to go negative "naturally"
        vec3 newIdeal = ideal;
        //newIdeal = vec3(264./360.,1.,0.45);
        if (ideal.y < 0.) {
            newIdeal.x += 0.5;
            newIdeal.y = -newIdeal.y;
        }

        // these make the gray part of the saturation slider a bit "magnetic"
        //newIdeal.y = pow(newIdeal.y,1.5);

        vec3 rgbIdeal = okhsl_to_srgb(newIdeal);

        // determines the inverse of the proportion of colors that will go to the colorblind subset
        float dim_size = 32.; // this should probably be a uniform
        float inv_prop = 2.;
        if (type == 4) inv_prop = 4.;
        if (type == 5) inv_prop = 10000000000.;
        float dist = 0.;
        vec4 newPosition = vec4(0.0);

        // what to do for types of colorblindness
        if (type > 0) {

            // if compact, then the position will take the colorblind position whether or not the color is supposed to be colorblind 
            if (compact) {

                color = placement(position);
                newPosition = vec4(convert(blindness_transform(color)), 1.0);
                if (type == 5) {
                    color = blindness_transform(color);
                    newPosition = vec4(convert(color),1.0);
                    }
                if (type == 5) dist = 0.1;
                else dist = clamp(0.5*distance(newPosition.xyz,convert(blindness_transform(rgbIdeal))),0.0,1.0);
                gl_PointSize = (pow(1. - dist, focus * 40.0)) * (30. - 20. * (1.0 - focus)) + 1.;
            }

            else if (is_sent_to_colorblind_subspace(position, dim_size, int(inv_prop))) {

                color = placement(position);
                dist = clamp(0.5*distance(convert(color),convert(rgbIdeal)),0.0,1.0);
                color = blindness_transform(color);
                newPosition = vec4(convert(color), 1.0);
                gl_PointSize = (pow(1. - dist, focus * 40.0)) * (30. - 20. * (1.0 - focus)) + 1.;
            }
            else {

                if (order) color = placement(position + pow(severity, 0.25) * (inv_prop/(inv_prop - 1.) * mod(position, inv_prop/dim_size) - mod(position, inv_prop/dim_size) - 1./dim_size));
                else color = placement(position + inv_prop/(inv_prop - 1.) * mod(position, inv_prop/dim_size) - mod(position, inv_prop/dim_size) - 1./dim_size);

                dist = clamp(0.5*distance(convert(blindness_transform(color)),convert(blindness_transform(rgbIdeal))),0.0,1.0);
                gl_PointSize = (pow(1. - dist, focus * 40.0)) * (mix(30.,21., pow(severity,1./8.)) - 20. * (1.0 - focus)) + 1.; // makes points bigger when they are near the focus
                newPosition = vec4(convert(color), 1.0);
            }
        }
        else {

            color = placement(position);
            dist = clamp(0.5*distance(convert(color),convert(rgbIdeal)),0.0,1.0);
            //dist = clamp(0.5*distance(convert(color),2.8*vec3(0.45201-0.5, -0.03246, -0.31153)),0.0,1.0);
            gl_PointSize = (pow(1. - dist, focus * 40.0)) * (30. - 20. * (1.0 - focus)) + 1.;
            newPosition = vec4(convert(color), 1.0);
        }

        alpha = pow(clamp(1.0 - dist * focus, 0.5, 1.0),3.0);

        newPosition = newPosition.zxyw;
        if (!truecloud) {
            if (mode == 1) newPosition = newPosition * vec4(vec3(1.3,1.,1.7),1.);
            if (mode == 2) newPosition = newPosition * vec4(vec3(1.,1.8,1.),1.);
            if (mode == 3) newPosition = newPosition * vec4(vec3(1.3,0.9,1.3),1.);
        }

        newPosition.x -= 0.0;
        newPosition.y -= 0.1;
        newPosition.z -= 0.0;

        alpha = pow(clamp(1.0 - dist * focus, .8, 1.0),3.0);
        if (isolate) if (alpha < 0.85) newPosition = vec4(vec3(10.),0.0);

        gl_Position = projectionMatrix * modelViewMatrix * newPosition;
    }
</script>
<script type="x-shader/x-fragment" id="RGBFragmentShader">
    varying vec3 color;
    varying float alpha;
    uniform bool isolate;
    uniform bool truecloud;
    uniform int type;

    void main() {

        vec3 okcolor = srgb_to_okhsl(color);
        if (!truecloud) okcolor.y = pow(okcolor.y,1.75); // desaturates colors, making gray easier to see
        vec3 new_color = okhsl_to_srgb(okcolor);

        gl_FragColor.rgb = new_color * alpha;
        gl_FragColor.a = clamp(alpha + 0.1,0.,1.0);
        if (isolate) if (alpha < 0.85) gl_FragColor = vec4(0.0);
        if (type == 5) gl_FragColor.a = 1.0;
        //if (isolate) if ((alpha < 0.9) && (okcolor.y < 0.7)) gl_FragColor.a = 0.0;
    }
</script>
<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.147.0';

    var height = Math.min(480, document.body.clientWidth);
    var width = height;

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera( 2 / - 2, 2 / 2, 2 / 2, 2 / - 2, 0, 1000 );

    const renderer = new THREE.WebGLRenderer({canvas: document.querySelector("canvas"), alpha: true, premultipliedAlpha: true, antialias: true});
    renderer.setSize(width, height);
    console.log(typeof(getComputedStyle(document.documentElement).getPropertyValue('--ft')));
    renderer.setClearColor(0x000000, 0.0);
    const canvas = document.getElementById('canvas');
    const div = document.getElementById('div');

    // lights and camera

    camera.position.z = 0;
    camera.position.y = 0;
    camera.rotation.x = 0;

    camera.zoom = 2;
    camera.updateProjectionMatrix();

    const colorSpaceMaterial = new THREE.ShaderMaterial({
        vertexShader: document.getElementById('colors').text + document.getElementById('RGBVertexShader').text,
        fragmentShader: document.getElementById('colors').text + document.getElementById('RGBFragmentShader').textContent,
        uniforms: {
            pointSize: { value: .1 },
            ideal: {
                type: "3f",
                value: new THREE.Vector3(0, 1., 0.5)
            },
            time: { value: .0 },
            isolate: { value: 0. },
            truecloud: {value: 0.},
            order: {value: 0.},
            mode: {value: 1},
            type: {value: 0},
            compact: {value: 0},
            severity: {value: 0.8},
            theta1: {value: 0.0},
            theta2: {value: 0.0},
            theta3: {value: 0.0},
            focus: { value: .5 },
            orientationLock: {value: 0.},
            orientation: {value: 0.}
        }
    });

    const cube_height = 32
    const cube_width = cube_height
    const cube_depth = cube_height

    const geometry = new THREE.BufferGeometry();
    const positions = [];
    let counter = 0;
    for (let i = 0; i < cube_height; i += 1)
        for (let j = 0; j < cube_width; j += 1) {
            for (let k = 0; k < cube_depth; k += 1) {
                // positions

                const x = (i + 0.5) / cube_height;
                const y = (j + 0.5) / cube_width;
                const z = (k + 0.5) / cube_depth;

                positions.push(x, y, z);
                counter++;
            }
        }

    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.computeBoundingSphere();

    const points = new THREE.Points(geometry, colorSpaceMaterial);
    scene.add(points);
    points.scale.set(0.33, 0.33, 0.33);
    points.position.x = 0;
    points.position.y = 0;
    points.position.z = -1;

    const linegeometry = new THREE.CylinderGeometry( .001, .001, 1, 32 ); 
    const linematerial = new THREE.MeshBasicMaterial( {color: 0x60606060} ); 
    const line = new THREE.Mesh( linegeometry, linematerial );

    scene.add(line);
    line.position.x = 0.0;
    line.position.y = 0.;
    line.position.z = -1.;
    //circle.rotation.x = 3.14/2;

    points.attach(line)








    const maxVerticalOrientation = 1.6;

    var mouseDown = false,
    mouseX = 0,
    mouseY = 0,
    deltaX,
    deltaY;
    var events = 0,
    totalX = 0,
    totalY = 0,
    momentumID;
    var orientation = 0.0;
    var colorFocus = [0,1.0,0.5]

    var orientationCheckbox = document.getElementById("orientation");
    orientationCheckbox.onchange = function(){
        if (document.getElementById("orientation").checked) orientation -= colorFocus[0];
        else orientation += colorFocus[0];
        orientation = orientation % 1.
    }

    var poleCheckbox = document.getElementById("pole");
    poleCheckbox.onchange = function(){
        if (document.getElementById("pole").checked) line.visible = true;
        else line.visible = false;
    }

    div.addEventListener('pointerdown', function (event) {
        event.preventDefault();
        events = 0;
        mouseDown = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
    }, false);

    document.addEventListener('pointermove', function (event) {
        if (!mouseDown) {return} // is the button pressed?
            event.preventDefault();
            deltaX = event.clientX - mouseX
            deltaY = event.clientY - mouseY
            mouseX = event.clientX;
            mouseY = event.clientY;
            totalX += deltaX;
            totalY += deltaY;
            events++;
            points.rotation.y += deltaX * 0.01;
            //points.rotation.x += deltaY * 0.01;
            //if (Math.abs(points.rotation.x) < maxVerticalOrientation) points.rotation.x += deltaY * 0.01;
            if (!document.getElementById("verticallock").checked) {
                if (deltaY * points.rotation.x < 0.) points.rotation.x += deltaY * 0.01;
                else points.rotation.x += deltaY * 0.01 * (maxVerticalOrientation - Math.abs(points.rotation.x));
            }
        }, false);

    document.addEventListener('pointerup', function (event) {
        event.preventDefault();
        mouseDown = false;
        if ((mouseX == event.clientX - deltaX) && (mouseY == event.clientY - deltaY)) {
            totalX = 0;
            totalY = 0;
        }
        beginMomentumTracking();
    }, false);

    function beginMomentumTracking(){
        cancelMomentumTracking();
        momentumID = requestAnimationFrame(momentumLoop);
        //renderer.render(scene, camera);
    }

    function cancelMomentumTracking(){
        cancelAnimationFrame(momentumID);
    }

    function momentumLoop(){
        if (events != 0){
            points.rotation.y += totalX / events * 0.01;
            //points.rotation.x += totalY / events * 0.01;
            if (!document.getElementById("verticallock").checked) {
                if (totalY / events * points.rotation.x < 0.) points.rotation.x += totalY / events * 0.01;
                else points.rotation.x += totalY / events * 0.01 * (maxVerticalOrientation - Math.abs(points.rotation.x));
            }
        }
        totalX = totalX * 0.966;
        totalY = totalY * 0.966;
        renderer.render(scene, camera);
        if (Math.abs(totalX) > 0.5 || Math.abs(totalY) > 0.5){
            momentumID = requestAnimationFrame(momentumLoop);
        }
    }

    function animate(time) {
        requestAnimationFrame(animate);
        points.material.uniforms.time.value = time;
        points.material.uniforms.isolate.value = document.getElementById("isolate").checked;
        points.material.uniforms.truecloud.value = true;
        points.material.uniforms.order.value = document.getElementById("order").checked;
        points.material.uniforms.mode.value = parseInt(document.querySelector('input[name="mode"]:checked').value);
        points.material.uniforms.type.value = parseInt(document.querySelector('input[name="type"]:checked').value);
        points.material.uniforms.compact.value = document.getElementById("compact").checked;
        points.material.uniforms.orientationLock.value = document.getElementById("orientation").checked;
        points.material.uniforms.orientation.value = orientation;
        renderer.render(scene, camera);
    }
    animate();

    function makeSlider(name, def, icon, range, func) {
        var svgIcon = d3.select('svg#' + icon)
        var sliderFill = d3
            .sliderBottom()
            .min(d3.min(range))
            .max(d3.max(range))
            .width(Math.min(300,screen.width*0.55))
            .tickFormat(d3.format('.0%'))
            .ticks(5)
            .default(def)
            .fill('#415794')
            .handle(
            d3
                .symbol()
                .type(d3.symbolCircle)
                .size(250)
            )
            .on('onchange', func);
        var gFill = d3
            .select('div#' + name)
            .append('svg')
            .attr('width', Math.min(400,screen.width*0.7))
            .attr('height', 65)
            .append('g')
            .attr('transform', 'translate(50,30)')
            .attr('fill', '#aaaaaa')
        gFill.call(sliderFill);
        gFill.append('g').attr('transform', 'translate(-50,-12)').node().appendChild(svgIcon.node())
        //svgIcon.attr('transform', 'translate(30,30)')
    }

    makeSlider('sliders', 0.0, "hue", [0.0,1.0], val => {
        colorFocus = [val, colorFocus[1], colorFocus[2]]
        points.material.uniforms.ideal.value = new THREE.Vector3(colorFocus[0], colorFocus[1], colorFocus[2]);});
        
    makeSlider('sliders', 1.0, "sat", [-1.0,1.0], val => {
        colorFocus = [colorFocus[0], val, colorFocus[2]]
        points.material.uniforms.ideal.value = new THREE.Vector3(colorFocus[0], colorFocus[1], colorFocus[2]);});
    makeSlider('sliders', 0.5, "val", [0.0,1.0], val => {
        colorFocus = [colorFocus[0], colorFocus[1], val]
        points.material.uniforms.ideal.value = new THREE.Vector3(colorFocus[0], colorFocus[1], colorFocus[2]);});
    makeSlider('sliders', 0.5, "foc", [0.0,1.0], val => {points.material.uniforms.focus.value = val;});
    makeSlider('sliders2', 0.8, "eye", [0.0,1.0], val => {points.material.uniforms.severity.value = val;});
    //makeSlider('sliders', 0., "foc", [0.0,2.0], val => {points.material.uniforms.theta1.value = val * Math.PI;});
    //makeSlider('sliders', 0., "foc", [0.0,2.0], val => {points.material.uniforms.theta2.value = val * Math.PI;});
    //makeSlider('sliders', 0., "foc", [0.0,2.0], val => {points.material.uniforms.theta3.value = val * Math.PI;});

    function updateWindow(){
        height = Math.min(480, document.body.clientWidth);
        width = height;
		renderer.setSize(width, height);
	}
	d3.select(window).on('resize.updatesvg', updateWindow);

    function keySwitch() {
    switch(event.keyCode) {
        case 79: 
            document.getElementById("order").checked = true
            break
        case 73: 
            document.getElementById("flow").checked = true
            break
        case 69: 
            document.getElementById("edge").checked = true
            break
        case 70: 
            document.getElementById("isolate").checked = !document.getElementById("isolate").checked
            break
        case 84: 
            document.getElementById("truecloud").checked = !document.getElementById("truecloud").checked
            break
        case 86: 
            document.getElementById("verticallock").checked = !document.getElementById("verticallock").checked
            break

        }
    }

    window.addEventListener('keydown', keySwitch);

</script>
	</article>
</main>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css"
  integrity="sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js"
  integrity="sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp" crossorigin="anonymous"></script>

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js"
  integrity="sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      
      
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
      ],
      
      throwOnError: false
    });
  });
</script>







  <footer class="mt-8 flex sm:flex-col-reverse justify-between items-center">
  <p class="mt-0 text-sm">
    TH ↔ Þ
  </p>
  <p class="flex items-center mt-0">
    
      <a class="icon mx-2" href="https://github.com/agaura" title="github">
      
        <svg fill="#63636f" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="https://www.instagram.com/arg793/" title="instagram">
      
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill = "#bc2a8d" d="M12 2.163c3.204 0 3.584.012 4.85.07 3.252.148 4.771 1.691 4.919 4.919.058 1.265.069 1.645.069 4.849 0 3.205-.012 3.584-.069 4.849-.149 3.225-1.664 4.771-4.919 4.919-1.266.058-1.644.07-4.85.07-3.204 0-3.584-.012-4.849-.07-3.26-.149-4.771-1.699-4.919-4.92-.058-1.265-.07-1.644-.07-4.849 0-3.204.013-3.583.07-4.849.149-3.227 1.664-4.771 4.919-4.919 1.266-.057 1.645-.069 4.849-.069zm0-2.163c-3.259 0-3.667.014-4.947.072-4.358.2-6.78 2.618-6.98 6.98-.059 1.281-.073 1.689-.073 4.948 0 3.259.014 3.668.072 4.948.2 4.358 2.618 6.78 6.98 6.98 1.281.058 1.689.072 4.948.072 3.259 0 3.668-.014 4.948-.072 4.354-.2 6.782-2.618 6.979-6.98.059-1.28.073-1.689.073-4.948 0-3.259-.014-3.667-.072-4.947-.196-4.354-2.617-6.78-6.979-6.98-1.281-.059-1.69-.073-4.949-.073zm0 5.838c-3.403 0-6.162 2.759-6.162 6.162s2.759 6.163 6.162 6.163 6.162-2.759 6.162-6.163c0-3.403-2.759-6.162-6.162-6.162zm0 10.162c-2.209 0-4-1.79-4-4 0-2.209 1.791-4 4-4s4 1.791 4 4c0 2.21-1.791 4-4 4zm6.406-11.845c-.796 0-1.441.645-1.441 1.44s.645 1.44 1.441 1.44c.795 0 1.439-.645 1.439-1.44s-.644-1.44-1.439-1.44z"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="https://www.linkedin.com/in/alexander-gaura-19980514a/" title="linkedin">
      
        <svg fill="#0073b1" width="18" role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>LinkedIn</title><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"/></svg>
      
      </a>
    
      <a class="icon mx-2" href="/index.xml" title="rss">
      
        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill = "#ee802f" d="M6.503 20.752c0 1.794-1.456 3.248-3.251 3.248-1.796 0-3.252-1.454-3.252-3.248 0-1.794 1.456-3.248 3.252-3.248 1.795.001 3.251 1.454 3.251 3.248zm-6.503-12.572v4.811c6.05.062 10.96 4.966 11.022 11.009h4.817c-.062-8.71-7.118-15.758-15.839-15.82zm0-3.368c10.58.046 19.152 8.594 19.183 19.188h4.817c-.03-13.231-10.755-23.954-24-24v4.812z"/></svg>
      
      </a>
    
  </p>
</footer>
</body>
</html>